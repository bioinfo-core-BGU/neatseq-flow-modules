library("optparse")
library("ggplot2")
library("pheatmap")
library("mclust")
library("factoextra")
library("cowplot")
library("gridExtra")
library("dplyr")
library("stringr")
library("openxlsx")
library("RColorBrewer")
library("colorspace")
library("DEP")
library('DEqMS')
theme_set(theme_half_open())
args = commandArgs(trailingOnly=TRUE)

option_list = list(
  make_option(c("-c", "--ProteinGroups_DATA_FILE"), type="character", default=NA, 
              help="Path to a tabular input file (e.g. txt files) as generated by quantitative analysis softwares of raw mass spectrometry data, such as MaxQuant or IsobarQuant", metavar="character"),
  make_option(c("--ProteinGroups_SOURCE"), type="character", default='LFQ', 
              help="The Source of the raw mass spectrometry Data Files ['LFQ','TMT','MATRIX']", metavar="character"),
  make_option(c("-s", "--SAMPLE_DATA_FILE"), type="character", default=NA, 
              help="Path to Samples Information File, First col is of samples names and must include a 'condition' column", metavar="character"),  
  make_option(c("--SUBSET_SAMPLES"), type="character", default=NA, 
              help="Use a Subset of Samples from SAMPLE_DATA_FILE. Character vector with samples name [comma sep]", metavar="character"),
  make_option(c("--EXCLUDE_SAMPLES"), type="character", default=NA, 
              help="Exclude Samples from SAMPLE_DATA_FILE. Character vector with samples name [comma sep]", metavar="character"),			  
  make_option(c("-o","--outDir"), type="character", default=NA, 
              help="path to the output directory", metavar="character"),
  make_option(c("-t", "--GENE_ID_TYPE"), type="character", default=NA, 
              help="The Gene ID Type ", metavar="character"),
  make_option(c("-d", "--Annotation_db"), type="character", default=NA, 
              help="Bioconductor Annotation Data Base Name from https://bioconductor.org/packages/release/BiocViews.html#___OrgDb  ", metavar="character"),
  make_option(c("--Species"), type="character", default=NA, 
              help="Species Name to Retrieve Annotation Data from ENSEMBL", metavar="character"),
  make_option(c("--KEGG_Species"), type="character", default=NA, 
              help="Species Name to Retrieve Annotation Data from KEGG", metavar="character"),
  make_option(c("--KEGG_KAAS"), type="character", default=NA, 
              help="Protein to KO file [Tab delimited file: first column Protein id, second column KO number]", metavar="character"),
  make_option(c("--FILTER_SAMPLES"), action="store_true",default=FALSE, 
              help="Filter Samples with High Number of Missing Values", metavar="character"),
  make_option(c("--FILTER_PROTEIN"), action="store_true",default=TRUE, 
              help="Filter Proteins High Number of Missing Values", metavar="character"),
  make_option(c("--FILTER_PROTEIN_CUTOFF"), type="numeric", default = 0, 
              help="The dataset is filtered for proteins that have a maximum of 'X' missing values in at least one condition", metavar="character"),
  make_option(c("--FILTER_SAMPLES_CUTOFF"), type="numeric", default = 0.1, 
              help="The dataset is filtered for samples that have less then 'X' fraction [0-1] of missing values", metavar="character"),
  
  make_option(c("--Add2Count"), type="numeric", default = 0, 
              help="Add This Number to All the Count Data ", metavar="character"),
  make_option(c( "--Trinotate"), type="character", default=NA, 
              help="Path to a Trinotate annotation file in which the first column is the genes names", metavar="character"),
  make_option(c( "--Rmarkdown"), type="character", default=NA, 
              help="Path to a Rmarkdown File [ usually 'Proteomics_module.Rmd' ]", metavar="character"),
  
  make_option(c("-n", "--NORMALIZATION_TYPE"), type="character", default='VSD', 
              help="The Normalization Type To Use [VSD , LOG2] The Default is VSD", metavar="character"),
  make_option(c("-i", "--IMPUTATION_METHOD"), type="character", default='MinProb', 
              help="The imputation method to use [MLE, MinProb, knn, QRILC, man] The Default is MinProb", metavar="character"),
  make_option(c("--IMPUTATION_SHIFT"), type="numeric", default = 1.8, 
              help="If a manual 'man' imputation method was selected, this value set the shift [default 1.8]", metavar="character"),
  make_option(c("--IMPUTATION_SCALE"), type="numeric", default = 0.3, 
              help="If a manual 'man' imputation method was selected, this value set the scale [default 0.3]", metavar="character"),
  make_option(c("--DESIGN"), type="character", default='~0 + condition', 
              help="The Main Limma Design", metavar="character"),
  make_option(c("--ALPHA"), type="numeric", default = 0.05, 
              help="Significant Level Cutoff, The Default is 0.05", metavar="character"),
  make_option(c("--Post_statistical_ALPHA"), type="numeric", default = NA, 
              help="Post Statistical FDR P-value Filtering ", metavar="character"),
  make_option(c("--FoldChange"), type="numeric", default = 1, 
              help="Fold change Cutoff [testing for fold changes greater in absolute value], The Default is 1", metavar="character"),
  make_option(c("--Post_statistical_FoldChange"), type="numeric", default = NA, 
              help="Post Statistical Fold change Filtering ", metavar="character"),
  make_option(c("--CONTRAST"), type="character", default=NA,
              help="The Limma Contrast Design", metavar="character"),
  make_option(c("--removeBatchEffect"), type="character", default=NA,
              help="Will Remove Batch Effect from the Normalized counts data up to 2 [using the limma package and only one using the sva package] Batch Effect fields [from the Sample Data ] separated by , ", metavar="character"),
  make_option(c("--removeBatchEffect_method"), type="character", default="sva",
              help="The method to Remove Remove Batch Effect from the Normalized counts data using the limma or sva packages [sva is the default] ", metavar="character"),
  make_option(c("--USEDEqMS"), action="store_true",default=FALSE, 
              help="Use the DEqMS package for peptide count correction", metavar="character"),
  make_option(c("--collapseReplicates"), type="character", default=NA,
              help="Will collapse technical replicates using a Sample Data field indicating which samples are technical replicates", metavar="character"),
  make_option(c("--SEED"), type="numeric", default = NA, 
              help="Set a Seed for this analysis", metavar="character"),
  
  make_option(c("--GENES_PLOT"), type="character", default=NA,
              help="Genes Id To Plot count Data [separated by ,] ", metavar="character"),
  make_option(c("--X_AXIS"), type="character", default=NA,
              help="The Filed In the Sample Data To Use as X Axis ", metavar="character"),
  make_option(c("--GROUP"), type="character", default=NA,
              help="The Filed In the Sample Data To Group By [can be two fields separated by ,]", metavar="character"),
  make_option(c("--SPLIT_BY"), type="character", default=NA,
              help="The Filed In the Sample Data To Split the Analysis By ", metavar="character"),
  make_option(c("--SPLIT_BY_CONTRAST"), action="store_true",default=FALSE, 
              help="Only use Samples found in the relevant contrast for Clustering and Enrichment Analysis", metavar="character"),
  
  make_option(c("--FUNcluster"), type="character", default='hclust',
              help='A clustering function including [kmeans,pam,clara,fanny,hclust,agnes,diana,click]. The default is hclust', metavar="character"),
  make_option(c("--hc_metric"), type="character", default='pearson',
              help="Hierarchical clustering metric to be used for calculating dissimilarities between observations. The default is pearson", metavar="character"),
  make_option(c("--hc_method"), type="character", default='ward.D2',
              help="Hierarchical clustering agglomeration method to be used. The default is ward.D2 ", metavar="character"),
  make_option(c("--CLICK_PATH"), type="character", default=NA,
              help="The path to CLICK program (Shamir et al. 2000). If your using click cite: CLICK and Expander ( Shamir et al. 2000 and Ulitsky et al. 2010) ", metavar="character"),
  make_option(c("--CLICK_HOMOGENEITY"), type="numeric", default=0.5,
              help="The HOMOGENEITY [0-1] of clusters using CLICK program (Shamir et al. 2000). The default is 0.5 ", metavar="character"),
  
  
  make_option(c("--k.max"), type="numeric", default=20,
              help="The maximum number of clusters to consider, must be at least two. The default is 20", metavar="character"),
  make_option(c("--nboot"), type="numeric", default=10,
              help="Number of Monte Carlo (bootstrap) samples for determining the number of clusters [Not For Mclust]. The default is 10 ", metavar="character"),
  make_option(c("--gap_maxSE_method"), type="character", default='firstSEmax',
              help="eclust parameter for determining the number of clusters [Not For Mclust]. The default is firstSEmax ", metavar="character"),
  make_option(c("--gap_maxSE_SE.factor"), type="numeric", default=1,
              help="eclust parameter for determining the number of clusters [Not For Mclust] higher number is less sensitive. The default is 1 ", metavar="character"),
  
  make_option(c("--stand"), action="store_true",default=FALSE, 
              help="The Data will be Standardized Before Clustering", metavar="character"), 
  make_option(c("--Mclust"), action="store_true",default=FALSE, 
              help="Use Mclust for determining the number of clusters", metavar="character"), 
  
  make_option(c("--GO_Enrichment_Type"), type="character",default='BP', 
              help="GO Enrichment Type To Perform, Can be a comma separated list [The Default is BP, Options include BP,MF and CC]", metavar="character"),
  make_option(c("--Enrichment_pvaluecutoff"), type="numeric",default=0.05, 
              help="Enrichment Pvalue Cutoff [If set to 1 will output all terms]", metavar="character"),
  make_option(c("--Enrichment_padjustmethod"), type="character",default='fdr', 
              help="Enrichment Method for multiple testing correction", metavar="character"),
  make_option(c("--KEGG_Enrichment_of"), type="character",default='pathway', 
              help="Find Enrichment of pathways or KOs", metavar="character"),
  make_option(c("--Filter_KEGG_pathways_by_taxon"), type="character",default=NA, 
              help="Only Test Enrichment for KEGG Pathways found in a Taxon", metavar="character"),
  make_option(c("--Enriched_terms_overlap"), action="store_true",default=FALSE, 
              help="Test for genes overlap in enriched terms", metavar="character"),
  make_option(c("--USE_INPUT_GENES_AS_BACKGROUND"), action="store_true",default=FALSE, 
              help="Use The input Genes as the Background for Enrichment Analysis", metavar="character"),
  make_option(c("--GO_Heatmap"), type="character", default=NA,
              help="Use these GO IDs list to create a heatmap per-GO-ID showing only significant genes that belong to this GO term [a comma separated list]", metavar="character"),
  make_option(c("--Max_Dotplot"), type="numeric", default=100,
              help="The maximal number of terms that will be plot in the enrichment dotplot per cluster", metavar="character"),

  make_option(c("--PCA_COLOR"), type="character", default=NA,
              help="The Filed In the Sample Data To Determine Color In The PCA Plot", metavar="character"),
  make_option(c("--PCA_SHAPE"), type="character", default=NA,
              help="The Filed In the Sample Data To Determine Shape In The PCA Plot", metavar="character"),
  make_option(c("--PCA_SIZE"), type="character", default=NA,
              help="The Filed In the Sample Data To Determine Size In The PCA Plot", metavar="character"),
  
  make_option(c("--RandomForest"), type="character", default=NA,
              help="Filed In the Sample Data To Classify By Using Random-Forest. ", metavar="character"), 
  make_option(c("--RF-Importance"), type="numeric", default=0,
              help="The Random-Forest Importance Cutoff to choose Genes. The default is 0", metavar="character"),
  make_option(c("--RF-Trees"), type="numeric", default=500,
              help="The Random-Forest Number of Trees to Generate. The default is 500", metavar="character"),
  
  
  
  make_option(c("--only_clustering"), action="store_true",default=FALSE, 
              help="Don't Perform Differential Analysis!!!", metavar="character"), 
  make_option(c("--significant_genes"), type="character", default=NA,
              help="Use these genes as the set of significant genes [a comma separated list]", metavar="character"),
  make_option(c("--significant_genes_file"), type="character", default=NA,
              help="Use these genes as the set of significant genes [gene per line in this file]", metavar="character"),
  make_option(c("--Genes_file"), type="character", default=NA,
              help="Use only these genes in the analysis [gene per line in this file]", metavar="character")
); 


#Get user information
opt_parser = optparse::OptionParser(usage = "usage: %prog [options]", 
                                    option_list=option_list,
                                    epilogue="\n\nAuthor:Liron Levin");
opt = optparse::parse_args(opt_parser);


Pathway_show_cutoff = 1
Pathway_up_color    = 'HotPink'
Pathway_down_color  = 'DeepSkyBlue'

print("Input var:",,quote = F)
print.data.frame(as.data.frame(x = unlist(opt),row.names = names(opt)),right = F,quote = F)

# Check if required packages are installed:
if(!(all(c('DESeq2') %in% installed.packages()))) {
  if (Sys.getenv("CONDA_PREFIX")!=""){
    source("http://bioconductor.org/biocLite.R")
    biocLite('DESeq2')
    library('DESeq2',character.only =T)
  }else{
    cat("The Bioconductor DESeq2 package is not installed. You must install it for this script to work!")
  }
}else{
  library('DESeq2',character.only =T)  
} 


if (!is.na(opt$SEED)){
   if (is.numeric(opt$SEED)){
       set.seed(opt$SEED)  
   }else{
      stop("Your Seed is not a number")
   }
}


#####################Functions################################

GetcountDataFromHTSeqCount <- function(sampleTable) # This function was modified from the original DESeq2 DESeqDataSetFromHTSeqCount function 
{
  l <- lapply( as.character( sampleTable[,2] ), function(fn) read.table( file.path( fn ), fill=TRUE ) )
  if( ! all( sapply( l, function(a) all( a$V1 == l[[1]]$V1 ) ) ) )
    stop( "Gene IDs (first column) differ between files." )
  # select last column of 'a', works even if htseq was run with '--additional-attr'
  tbl <- sapply( l, function(a) a[,ncol(a)] )
  colnames(tbl) <- sampleTable[,1]
  rownames(tbl) <- l[[1]]$V1
  rownames(sampleTable) <- sampleTable[,1]
  oldSpecialNames <- c("no_feature","ambiguous","too_low_aQual","not_aligned","alignment_not_unique")
  # either starts with two underscores
  # or is one of the old special names (htseq-count backward compatability)
  specialRows <- (substr(rownames(tbl),1,1) == "_") | rownames(tbl) %in% oldSpecialNames
  tbl <- tbl[ !specialRows, , drop=FALSE ]
  
  return(tbl)
}   


keggLink_retry <- function (Type,Data){
  error_flag=TRUE
  res=c()
  try_count=0
  while (error_flag ){
    try_count = try_count+1
    res<-try(keggLink(Type,Data),silent = T)
    if (!inherits(res,"try-error")){
      error_flag=FALSE
    }
  } 
  return(res)
}

plotPCA<-function (object, intgroup = "condition", ntop = 500, returnData = FALSE) { #This function was modified from the original DESeq2 plotPCA function
  if (ntop!='all'){
    rv <- genefilter::rowVars(assay(object))
    select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
                                                       length(rv)))]
    pca <- prcomp(t(assay(object)[select, ]))
  }else{
    pca <- prcomp(t(assay(object)))
  }
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(object)[, intgroup, 
                                               drop = FALSE])
  group <- if (length(intgroup) > 1) {
    factor(apply(intgroup.df, 1, paste, collapse = " : "))
  }else{
    colData(object)[[intgroup]]
  }
  d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2],PC3 = pca$x[, 3], group = group, 
                  intgroup.df, name = colnames(object))
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:3]
    return(d)
  }
  ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "group")) + 
    geom_point(size = 3) + xlab(paste0("PC1: ", round(percentVar[1] * 
                                                        100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] * 
                                                                                                            100), "% variance")) + coord_fixed()
}


cluster_enricher<-function(clusters,num,Type,organism,universe,keyType,Ontology="BP",pvalueCutoff=0.05,pAdjustMethod='fdr',qvalueCutoff=0.05){
  res_red=unique(names(clusters))
  Genes=res_red[res_red  %in% names(clusters[clusters %in% num])]
  if (Type=="GO"){
    res=enrichGO(gene      = Genes,
                 OrgDb         = organism,
                 universe      = universe,
                 keytype       = keyType,
                 ont           = Ontology,
                 pAdjustMethod = pAdjustMethod,
                 pvalueCutoff  = pvalueCutoff,
                 qvalueCutoff  = qvalueCutoff)
  }else{
    res=enrichKEGG(gene          = Genes, 
                   organism      = organism,
                   pAdjustMethod = pAdjustMethod,
                   pvalueCutoff  = pvalueCutoff,
                   qvalueCutoff  = qvalueCutoff,
                   universe      = universe,
                   keyType       = keyType,  
                   minGSSize     = 0,
                   maxGSSize     = length(res_red))
    
    
    
  }
  return(res)
}


clusters_enricher=function(outDir, clusters,Type,organism,universe,keyType,file_name,Ontology="BP",pvalueCutoff=0.05,pAdjustMethod='fdr',qvalueCutoff=0.05){
  allRes=list()
  cluster_names=list()
  count=1
  for (i in sort(unique(clusters))){
    temp=cluster_enricher(clusters,c(i),Type,organism,universe,keyType,Ontology,pvalueCutoff,pAdjustMethod,qvalueCutoff)
    if (length(temp)>0){
      allRes[count]<-temp
      cluster_names[count]=i
      count=count+1
    }
  } 
  names(allRes)=cluster_names
  allRes=clusterProfiler::merge_result(enrichResultList =allRes)
  allRes@fun<-"enrichGO"
  write.csv(x = allRes@compareClusterResult,
            file =file.path(outDir,file_name) ,
            quote = TRUE,
            row.names = TRUE)
  if (dim(allRes@compareClusterResult)[1]>0){
    if (Type=="GO"){
      allRes@fun<-"enrichGO"
      temp_allRes<-try(clusterProfiler::simplify(allRes, cutoff=0.7, by="p.adjust", select_fun=min),silent = T)
      if (!inherits(temp_allRes,"try-error")){
        allRes=temp_allRes
        file_name=paste("simplify",file_name,collapse = "_")
        write.csv(x = allRes@compareClusterResult,file =file.path(outDir,file_name) ,quote = FALSE,row.names = TRUE)
      }
    }else{
      allRes@fun<-"enrichKEGG"
    }
    if (dim(allRes@compareClusterResult)[1]>50){
      font.size=4
    }else{
      font.size=9
    }
    
    if (dim(allRes@compareClusterResult)[1]>0){
        enrichplot::dotplot(allRes,x=allRes@compareClusterResult$Cluster,font.size =font.size,showCategory=1000)+
        ggplot2::ggsave(filename = file.path(outDir,paste(file_name,".pdf",collapse = "")),dpi = 600,device = "pdf",width = 20,height = 20)
    }
  }
  return(allRes)
}


General_Enrichment_Test<-function(clusters,num,TERM2NAME,TERM2GENE,pAdjustMethod='fdr',pvalueCutoff=0.05){
  res_red=unique(TERM2GENE[,2])
  Genes=res_red[res_red  %in% names(clusters[clusters %in% num])]
  
  res=enricher(Genes, TERM2GENE=TERM2GENE, 
               TERM2NAME=TERM2NAME,
               minGSSize     = 0,
               maxGSSize     = length(res_red),
               pAdjustMethod = pAdjustMethod,
               pvalueCutoff  = pvalueCutoff
  ) 
  
  return(res)
}


generat_urls<-function(allRes,gene2ko){
  temp_table=allRes@compareClusterResult
  temp_table$URL=apply(X = temp_table,MARGIN = 1,FUN = function(x) paste(c("http://www.kegg.jp/kegg-bin/show_pathway?",stringi::stri_replace_all(str = x["ID"],replacement = "",regex = "path:",collapse = ""),"/", paste(sapply( unlist(stringi::stri_split(str = x["geneID"],regex = "/")),FUN = function(x) gene2ko[gene2ko$V1==x,"V2"]),collapse = "+") ),collapse = ""))
  allRes@compareClusterResult=temp_table
  return(allRes)
}


Clusters_Enrichment_Test=function(outDir,clusters,TERM2NAME,TERM2GENE,file_name,Type,pAdjustMethod='fdr',pvalueCutoff=0.05,gene2ko=FALSE){
  allRes=list()
  cluster_names=list()
  count=1
  for (i in sort(unique(clusters))){
    temp=General_Enrichment_Test(clusters,c(i),TERM2NAME,TERM2GENE,pAdjustMethod,pvalueCutoff )
    if (length(temp)>0){
      allRes[count]<-temp
      cluster_names[count]=i
      count=count+1
    }
  } 
  names(allRes)=cluster_names
  allRes=clusterProfiler::merge_result(enrichResultList =allRes)
  if (Type=="KO"){
    allRes<-generat_urls(allRes,gene2ko)
  }
  write.csv(x = allRes@compareClusterResult,
            file =file.path(outDir,file_name) ,
            quote = TRUE,
            row.names = TRUE)
  if (Type=="GO"){
    allRes@fun<-"enrichGO"
    temp_allRes<-try(clusterProfiler::simplify(allRes, cutoff=0.7, by="p.adjust", select_fun=min),silent = T)
    if (!inherits(temp_allRes,"try-error")){
      allRes=temp_allRes
      file_name=paste("simplify",file_name,collapse = "_")
      write.csv(x = allRes@compareClusterResult,file =file.path(outDir,file_name) ,quote = FALSE,row.names = TRUE)
    }
  }else{
    allRes@fun<-"enrichKEGG"
  }
  if (dim(allRes@compareClusterResult)[1]>50){
    font.size=4
  }else{
    font.size=9
  }
  
  if (dim(allRes@compareClusterResult)[1]>0){
      enrichplot::dotplot(allRes,showCategory=1000,font.size=font.size)+ 
      ggplot2::ggsave(filename = file.path(outDir,paste(file_name,".pdf",collapse = "")),dpi = 600,device = "pdf",width = 20,height = 20)
  }
  return(allRes)
}


OLD_plot_clusters<-function(clusters,vs_ano,color_group=c('Type','Time'),titles=c("Type","Time","Normalized counts"),split_by=c(),smooth=T,X_AXIS_ORDER=NA){
  plot_list  = list()
  title_list = list()
  count=1
  for (i in sort(unique(clusters))){
    Df=data.frame()
    genes=names(clusters[clusters==i])
    for (j in genes){
      if (length(split_by)>0){
        temp=subset.data.frame(x =vs_ano,,c(split_by,color_group,j))
        colnames(temp)=c("split_by","Type","Time","EXP")
        Df=rbind(Df,temp)
      }else{
        temp=subset.data.frame(x =vs_ano,,c(color_group,j))
        colnames(temp)=c("Type","Time","EXP")
        Df=rbind(Df,temp)
      }
    }
    if (color_group[1]==color_group[2]){
      Df$Type='Trend'
    }
    if (length(X_AXIS_ORDER)>1){
      Df$Time <-factor(Df$Time,levels=intersect(X_AXIS_ORDER,unique(Df$Time)))
    }
    if (length(split_by)>0){
      title_list[count]=list(c(i,length(genes)) ) 
      plot_list[count]=list(ggplot(data=Df, aes(x=Time, y=EXP, group=Type)) + 
                              facet_wrap(~split_by, ncol=1,scales = "free_y",strip.position = c("right"))+
                              theme(strip.text.y = element_text(size = 7, colour = "black"))+#,face="bold" ,angle = 90))+
                              #theme(strip.background = element_blank())+
                              ggtitle( paste(paste("Cluster ", i  ,sep="") ,length(genes) ,sep="\n")) +
                              #theme(plot.title = element_text(colour = "black", size = 12)) + 
                              theme(legend.position  ="none")+
                              xlab(titles[2]) +
                              ylab(titles[3]) +
                              theme(axis.title   = element_text(colour = "black", size = 10) )+
                              theme(legend.title = element_text(colour = "black", size = 10) )+
                              theme(legend.text  = element_text(colour = "black", size = 8) )+
                              theme(axis.text.y  = element_text(colour = "black", size = 6))+
                              theme(axis.text.x  = element_text(colour = "black", size = 6))+
                              theme(plot.margin  = unit(c(0.5,0.2,0.5,0.2),"cm")  )+
                              #scale_color_discrete(name=titles[1])+
                              #scale_linetype_manual(name=titles[1],values=c(1,5))+
                              scale_x_discrete(limits=unique(Df$Time))+
                              theme(legend.key.width =unit(3,"line")) 
                            #scale_y_continuous(breaks=c(seq(0,10,by=2)) )
      )
    }else{
      title_list[count]=list(c(i,length(genes)) ) 
      plot_list[count]=list(ggplot(data=Df, aes(x=Time, y=EXP, group=Type)) + 
                              ggtitle( paste(paste("Cluster ", i  ,sep="") ,length(genes) ,sep="\n")) +
                              #theme(plot.title = element_text(colour = "black", size = 12)) + 
                              theme(legend.position  ="none")+
                              xlab(titles[2]) +
                              ylab(titles[3]) +
                              theme(axis.title   = element_text(colour = "black", size = 10) )+
                              theme(legend.title = element_text(colour = "black", size = 10) )+
                              theme(legend.text  = element_text(colour = "black", size = 8) )+
                              theme(axis.text.y  = element_text(colour = "black", size = 6))+
                              theme(axis.text.x  = element_text(colour = "black", size = 6))+
                              theme(plot.margin  = unit(c(0.5,0.2,0.5,0.2),"cm")  )+
                              #scale_color_discrete(name=titles[1])+
                              #scale_linetype_manual(name=titles[1],values=c(1,5))+
                              scale_x_discrete(limits=unique(Df$Time))+
                              theme(legend.key.width = unit(3,"line")) 
                            #scale_y_continuous(breaks=c(seq(0,10,by=2)) )
      )
    }
    
    
    if (smooth){
      if (dim(Df)[1]<30000){
        old_plot = plot_list[[count]] 
        res <- try( list(plot_list[[count]] + 
                           stat_smooth(method="loess",
                                       fullrange=F,
                                       size=0.5,
                                       aes(linetype=Type,color=Type)) ),
                    silent = T)
        if (inherits(res,"try-error")){
          plot_list[count]=list(old_plot +
                           stat_smooth(method='glm',
                                       formula = y ~ poly(x, length(unique(Df$Time))-1),
                                       fullrange=F,
                                       size=0.5,
                                       aes(linetype=Type,color=Type)) 
                                )
          # plot_list[count]=list(plot_list[[count]] + 
          # stat_smooth(method="loess", span = 0.1 ,fullrange=F, size=0.5 ,aes(linetype=Type,color=Type)) 
          # )
        }else{
          plot_list[count]=res
          
        }
      }else{
        plot_list[count]=list(plot_list[[count]]+
                                stat_smooth(method='glm',
                                            formula = y ~ poly(x, length(unique(Df$Time))-1),
                                            fullrange=F,
                                            size=0.5,
                                            aes(linetype=Type,color=Type)) 
        )
      }
      gp2=plot_list[count]
      res<-try(get_legend(gp2[[1]] + theme(legend.position  ="right")+guides(color=guide_legend(title=titles[1]),linetype=guide_legend(title=titles[1]))) ,silent = T)
      if (inherits(res,"try-error")){
        plot_list[count]=list(plot_list[[count]]+
                                stat_summary(fun.y=mean, geom="point", size = 3,aes(color=Type))+
                                stat_summary(fun.data = "mean_se", geom = "errorbar", width = .3,size = 1,aes(color=Type),show.legend = F)
        )
      }
    }else{
      plot_list[count]=list(plot_list[[count]]+
                              stat_summary(fun.y=mean, geom="line", size = 1.3,aes(linetype=Type,color=Type))+
                              stat_summary(fun.data = "mean_se", geom = "errorbar", width = .3,size = 1,aes(color=Type),show.legend = F)
      )
    }
    
    count=count+1  
  }
  
  # ml_plotly = sapply(X =c(1:length(plot_list)),
  # FUN = function(x) list(ggplotly(plot_list[[x]]) %>% 
  # style(text=paste(
  # paste("Cluster:",title_list[[x]][1],sep=" ") ,
  # paste("Number of Genes:",title_list[[x]][2],sep=" ") ,
  # sep = "<br />" ),
  # hoverinfo = "text")))
  
  # ml_plotly = subplot(c(ml_plotly),
  # nrows = ceiling(length(plot_list)/3),
  # titleX = T,
  # titleY  = F,
  # shareX = T,
  # shareY = F) %>%
  # layout(title='Clusters',legend = list(orientation = 'h', y = -0.2))
  gp2=plot_list[1]
  if (color_group[1]==color_group[2]){
    ml<-marrangeGrob(plot_list, nrow=2, ncol=3, top=NULL)
  }else{
    legend <- get_legend(gp2[[1]] + theme(legend.position  ="right")+guides(color=guide_legend(title=titles[1]),linetype=guide_legend(title=titles[1])))
    ml<-marrangeGrob(plot_list, nrow=2, ncol=3,right=legend, top=NULL)
    
  }
  
  return(list(ml))#,ml_plotly))
}


plot_clusters<-function(clusters,vs_ano,color_group=c('Type','Time'),titles=c("Type","Time","Normalized counts"),split_by=c(),smooth=T,X_AXIS_ORDER=NA){
  plot_list  = list()
  title_list = list()
  count=1
  for (i in sort(unique(clusters))){
    Df=data.frame()
    genes=names(clusters[clusters==i])
    for (j in genes){
      if (length(split_by)>0){
        temp=subset.data.frame(x =vs_ano,,c(split_by,color_group,j))
        colnames(temp)=c("split_by","Type","Time","EXP")
        Df=rbind(Df,temp)
      }else{
        temp=subset.data.frame(x =vs_ano,,c(color_group,j))
        colnames(temp)=c("Type","Time","EXP")
        Df=rbind(Df,temp)
      }
    }
    if (color_group[1]==color_group[2]){
      Df$Type='Trend'
    }
    if (length(X_AXIS_ORDER)>1){
      Df$Time <-factor(Df$Time,levels=intersect(X_AXIS_ORDER,unique(Df$Time)))
    }
    if (length(split_by)>0){
      title_list[count]=list(c(i,length(genes)) ) 
      plot_list[count]=list(ggplot(data=Df, aes(x=Time, y=EXP, group=Type)) + 
                              facet_wrap(~split_by, ncol=1,scales = "free_y",strip.position = c("right"))+
                              theme(strip.text.y = element_text(size = 7, colour = "black"))+#,face="bold" ,angle = 90))+
                              #theme(strip.background = element_blank())+
                              ggtitle( paste(paste("Cluster ", i  ,sep="") ,length(genes) ,sep="\n")) +
                              #theme(plot.title = element_text(colour = "black", size = 12)) + 
                              theme(legend.position  ="none")+
                              xlab(titles[2]) +
                              ylab(titles[3]) +
                              theme(axis.title   = element_text(colour = "black", size = 10) )+
                              theme(legend.title = element_text(colour = "black", size = 10) )+
                              theme(legend.text  = element_text(colour = "black", size = 8) )+
                              theme(axis.text.y  = element_text(colour = "black", size = 6))+
                              theme(axis.text.x  = element_text(colour = "black", size = 6))+
                              theme(plot.margin  = unit(c(0.5,0.2,0.5,0.2),"cm")  )+
                              #scale_color_discrete(name=titles[1])+
                              #scale_linetype_manual(name=titles[1],values=c(1,5))+
                              scale_x_discrete(limits=unique(Df$Time))+
                              theme(legend.key.width =unit(3,"line")) 
                            #scale_y_continuous(breaks=c(seq(0,10,by=2)) )
      )
    }else{
      title_list[count]=list(c(i,length(genes)) ) 
      plot_list[count]=list(ggplot(data=Df, aes(x=Time, y=EXP, group=Type)) + 
                              ggtitle( paste(paste("Cluster ", i  ,sep="") ,length(genes) ,sep="\n")) +
                              #theme(plot.title = element_text(colour = "black", size = 12)) + 
                              theme(legend.position  ="none")+
                              xlab(titles[2]) +
                              ylab(titles[3]) +
                              theme(axis.title   = element_text(colour = "black", size = 10) )+
                              theme(legend.title = element_text(colour = "black", size = 10) )+
                              theme(legend.text  = element_text(colour = "black", size = 8) )+
                              theme(axis.text.y  = element_text(colour = "black", size = 6))+
                              theme(axis.text.x  = element_text(colour = "black", size = 6))+
                              theme(plot.margin  = unit(c(0.5,0.2,0.5,0.2),"cm")  )+
                              #scale_color_discrete(name=titles[1])+
                              #scale_linetype_manual(name=titles[1],values=c(1,5))+
                              scale_x_discrete(limits=unique(Df$Time))+
                              theme(legend.key.width = unit(3,"line")) 
                            #scale_y_continuous(breaks=c(seq(0,10,by=2)) )
      )
    }
    
    
    if (smooth){
      if ( (dim(Df)[1]<30000) && (length(unique(Df$Time))>3)){
        old_plot = plot_list[[count]] 
        res <- try( list(plot_list[[count]] + 
                           stat_smooth(method="loess",
                                       fullrange=F,
                                       size=0.5,
                                       span=1,
                                       aes(linetype=Type,color=Type)) ),
                    silent = T)
        if (inherits(res,"try-error")){
          plot_list[count]=list(old_plot +
                           stat_smooth(method='glm',
                                       formula = y ~ poly(x, length(unique(Df$Time))-1),
                                       fullrange=F,
                                       size=0.5,
                                       aes(linetype=Type,color=Type)) 
                                )
          # plot_list[count]=list(plot_list[[count]] + 
          # stat_smooth(method="loess", span = 0.1 ,fullrange=F, size=0.5 ,aes(linetype=Type,color=Type)) 
          # )
        }else{
          plot_list[count]=res
          
        }
      }else{
        plot_list[count]=list(plot_list[[count]]+
                                stat_smooth(method='glm',
                                            formula = y ~ poly(x, length(unique(Df$Time))-1),
                                            fullrange=F,
                                            size=0.5,
                                            aes(linetype=Type,color=Type)) 
        )
      }
      gp2=plot_list[count]
      res<-try(get_legend(gp2[[1]] + theme(legend.position  ="right")+guides(color=guide_legend(title=titles[1]),linetype=guide_legend(title=titles[1]))) ,silent = T)
      if (inherits(res,"try-error")){
        plot_list[count]=list(plot_list[[count]]+
                                stat_summary(fun.y=mean, geom="point", size = 3,aes(color=Type))+
                                stat_summary(fun.data = "mean_se", geom = "errorbar", width = .3,size = 1,aes(color=Type),show.legend = F)
        )
      }
    }else{
      plot_list[count]=list(plot_list[[count]]+
                              stat_summary(fun.y=mean, geom="line", size = 1.3,aes(linetype=Type,color=Type))+
                              stat_summary(fun.data = "mean_se", geom = "errorbar", width = .3,size = 1,aes(color=Type),show.legend = F)
      )
    }
    
    count=count+1  
  }
  
  # ml_plotly = sapply(X =c(1:length(plot_list)),
  # FUN = function(x) list(ggplotly(plot_list[[x]]) %>% 
  # style(text=paste(
  # paste("Cluster:",title_list[[x]][1],sep=" ") ,
  # paste("Number of Genes:",title_list[[x]][2],sep=" ") ,
  # sep = "<br />" ),
  # hoverinfo = "text")))
  
  # ml_plotly = subplot(c(ml_plotly),
  # nrows = ceiling(length(plot_list)/3),
  # titleX = T,
  # titleY  = F,
  # shareX = T,
  # shareY = F) %>%
  # layout(title='Clusters',legend = list(orientation = 'h', y = -0.2))
  gp2=plot_list[1]
  num_of_plots=length(plot_list)
  if (num_of_plots <= 2) {
    grob_rows=1
    grob_cols=num_of_plots
  } else if (num_of_plots <= 4) {
    grob_rows = grob_cols = 2
  } else {
    grob_rows=2
    grob_cols=3
  }
  if (color_group[1]==color_group[2]){
    ml<-marrangeGrob(plot_list, nrow=grob_rows, ncol=grob_cols, top=NULL)
  } else {
    legend <- get_legend(gp2[[1]] + theme(legend.position  ="right")+guides(color=guide_legend(title=titles[1]),linetype=guide_legend(title=titles[1])))
    ml<-marrangeGrob(plot_list, nrow=grob_rows, ncol=grob_cols,right=legend, top=NULL)
  }
  
  return(list(ml))#,ml_plotly))
}


convert_agregate<-function(df,index,subject,sep){
  l1=apply(X = df,MARGIN = 1,FUN = function(x) {
    m=as.data.frame( x = stringi::stri_split(str = x[subject],regex = sep),col.names = c("v1"))
    m["index"]<-x[index]
    return(m[c("index","v1")])
  })
  return(do.call(what = "rbind",args = l1) )
}


plot_sheard_genes<-function(allRes,outDir,file_name){
  if (length(allRes)>1){
    for (cluster in unique(allRes$Cluster)){
      TEMP = na.omit(allRes[allRes$Cluster==cluster,])
      genes = unique(unlist(stringi::stri_split(paste(TEMP$geneID,sep = ,collapse = '/'),fixed = '/')))
      
      if ((length(TEMP$ID)>1) &&((length(genes)>1))){
        mat  = matrix(0, nrow = length(TEMP$ID), ncol = length(genes))
        rownames(mat) = TEMP$ID
        colnames(mat) = genes
        
        
        for (x in TEMP$ID){
          for (y in genes){
            mat[x,y] = length( unlist(intersect( unlist(stringi::stri_split(TEMP[TEMP$ID==x,'geneID'],fixed = '/')),y )))
            
          }
        }
        
        rownames(mat) = TEMP$Description
        
        if ((length(TEMP$ID)>20) || ((length(genes)>200))){
          heat_map = pheatmap(mat = mat,cluster_rows = T,
                              cluster_cols = T,
                              silent = T,
                              legend = F)
          
        }else{
          if (length(unique(as.vector(mat)))==2 ){
            color=colorRampPalette(c('white','pink'))(2)
            mybreaks=NA
          }else{
            color=colorRampPalette(c('pink'))(1)
            mybreaks=c(0,1)
          }
          heat_map = pheatmap(mat = mat,cluster_rows = T,
                              treeheight_col = 0,
                              treeheight_row = 0,
                              width = 5,
                              height =5,
                              cellheight = 10,
                              fontsize_row =5,
                              fontsize_col = 1,
                              main = paste('Cluster ',cluster),
                              border_color = 'white',
                              cluster_cols = T,
                              breaks = mybreaks,
                              filename = file.path(outDir,paste('Cluster',cluster,'_genes2term_',file_name,".pdf",collapse = "")),
                              color = color,
                              legend = F)
          
        }
        write.csv(x = mat[heat_map$tree_row$order,heat_map$tree_col$order],
                  quote = T,
                  row.names = T,
                  file = file.path(outDir,paste('Cluster',cluster,'_genes2term_',file_name,".csv",collapse = "")))
        
        
        mat  = matrix(0, nrow = length(TEMP$ID), ncol = length(TEMP$ID))
        rownames(mat) = TEMP$ID
        colnames(mat) = TEMP$ID
        
        for (x in TEMP$ID){
          for (y in TEMP$ID){
            mat[x,y] = (2*length( unlist(intersect( unlist(stringi::stri_split(TEMP[TEMP$ID==x,'geneID'],fixed = '/')),unlist(stringi::stri_split(TEMP[TEMP$ID==y,'geneID'],fixed = '/'))))))/(length(unlist(stringi::stri_split(TEMP[TEMP$ID==x,'geneID'],fixed = '/'))) +  length(unlist(stringi::stri_split(TEMP[TEMP$ID==y,'geneID'],fixed = '/'))))
            
          }
        }
        
        rownames(mat) = TEMP$Description
        colnames(mat) = TEMP$Description
        
        if (length(TEMP$ID)>20){
          heat_map = pheatmap(mat = mat,cluster_rows = T,
                              cluster_cols = T,
                              silent = T,
                              legend = T)
          
        }else{
          if (length(unique(as.vector(mat)))>1 ){
            color=colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name ="RdYlBu") ))( 100)
            mybreaks=seq(0,1,0.01)
          }else{
            color=colorRampPalette(c('red'))(1)
            mybreaks=c(0,1)
          }
          
          heat_map = pheatmap(mat = mat,cluster_rows = T,
                              width = 5,
                              height =5,
                              treeheight_col = 0,
                              treeheight_row = 0,
                              breaks = mybreaks,
                              fontsize_row =5,
                              fontsize_col = 5,
                              main = paste('Cluster ',cluster),
                              border_color = 'white',
                              cluster_cols = T,
                              color = color,
                              filename = file.path(outDir,paste('Cluster',cluster,'_term2term_',file_name,".pdf",collapse = "")),
                              legend = T)
        }
        write.csv(x = mat[heat_map$tree_row$order,heat_map$tree_col$order],
                  quote = T,
                  row.names = T,
                  file = file.path(outDir,paste('Cluster',cluster,'_term2term_',file_name,".csv",collapse = "")))
        
        
      }
    }
    
  }
}



Run_click<-function(mat,click_path,outDir,HOMOGENEITY = 0.5){
      InputFile = file.path(outDir,'clickInput.orig')
      writeLines(text =  paste(dim(mat)[1],dim(mat)[2],sep = ' ' ),con = InputFile)
      write.table(x = mat,append = T,file = InputFile ,sep = '\t',col.names = F)
      lines=c()
      lines = c(lines,'DATA_TYPE ')
      lines = c(lines,'FP ')
      lines = c(lines,'INPUT_FILES_PREFIX ')
      lines = c(lines,file.path(outDir,'clickInput '))
      lines = c(lines,'OUTPUT_FILE_PREFIX ')
      lines = c(lines,file.path(outDir,'clickOutput '))
      lines = c(lines,'SIMILARITY_TYPE ')
      lines = c(lines,'CORRELATION ')
      lines = c(lines,'HOMOGENEITY ')
      lines = c(lines,as.character(HOMOGENEITY))
      writeLines(text =  lines,con = file.path(outDir,'params.txt'))
      system(command = paste('chmod 777 ',InputFile,sep = ' ') )
      system(command = paste('chmod 777 ',file.path(outDir,'params.txt'),sep = ' ') )
      Sys.sleep(1)
      system(command = paste(click_path,file.path(outDir,'params.txt'),sep = ' '),wait = T )
      Sys.sleep(50)
      clusters = read.table(file = file.path(outDir,'clickOutput.res.sol'),sep = '\t',header = F,row.names = 1)
      clusters = setNames(unlist(as.list(clusters)), row.names(clusters))
      return(clusters)
}


Prepair_Normalized_counts_for_clustering <- function(Normalized_counts_assay,colData,opt){
  if (!is.na(opt$X_AXIS)){    
    X_AXIS=opt$X_AXIS
    if (is.na(opt$GROUP)){
      GROUP=X_AXIS
    }else{
      GROUP=opt$GROUP
    }
    if (X_AXIS!=GROUP){
      Normalized_counts_Annotated=merge(colData[c(X_AXIS,GROUP)],t(Normalized_counts_assay),all.x = T ,by="row.names",sort=F)
      Normalized_counts_Annotated_mean=aggregate.data.frame(x = Normalized_counts_Annotated,by = c(Normalized_counts_Annotated[GROUP],Normalized_counts_Annotated[X_AXIS]),FUN = mean)
      rownames(Normalized_counts_Annotated_mean)=paste(unlist(Normalized_counts_Annotated_mean[GROUP]),unlist(Normalized_counts_Annotated_mean[X_AXIS]))
      Normalized_counts_Annotated_mean=Normalized_counts_Annotated_mean[order(rownames(Normalized_counts_Annotated_mean)),]
      Normalized_counts_Annotated_mean$Row.names=NULL
      Normalized_counts_Annotated_mean[unique(c(X_AXIS,GROUP))]=NULL
      Normalized_counts_Annotated_mean[unique(c(X_AXIS,GROUP))]=NULL
      
      Heatmap_Normalized_counts_Annotated=Normalized_counts_Annotated
      rownames(Heatmap_Normalized_counts_Annotated)=make.unique(paste(unlist(Heatmap_Normalized_counts_Annotated[GROUP]),
                                                                      unlist(Heatmap_Normalized_counts_Annotated[X_AXIS]),
                                                                      unlist(Heatmap_Normalized_counts_Annotated['Row.names'])),
                                                                sep=' ')
      Heatmap_Normalized_counts_Annotated=Heatmap_Normalized_counts_Annotated[order(rownames(Heatmap_Normalized_counts_Annotated)),]
      Heatmap_Normalized_counts_Annotated[unique(c(X_AXIS,GROUP))]=NULL
      Heatmap_Normalized_counts_Annotated[unique(c(X_AXIS,GROUP))]=NULL
      row_names=Heatmap_Normalized_counts_Annotated$Row.names
      Heatmap_Normalized_counts_Annotated$Row.names=NULL
      row.names(Heatmap_Normalized_counts_Annotated)=row_names
      
    }else{
      Normalized_counts_Annotated=merge(colData[c(X_AXIS)],t(Normalized_counts_assay),all.x = T,by="row.names",sort=F)
      Normalized_counts_Annotated_mean=aggregate.data.frame(x = Normalized_counts_Annotated,by = Normalized_counts_Annotated[X_AXIS],FUN = mean)
      rownames(Normalized_counts_Annotated_mean)=unlist(Normalized_counts_Annotated_mean[X_AXIS])
      Normalized_counts_Annotated_mean=Normalized_counts_Annotated_mean[order(rownames(Normalized_counts_Annotated_mean)),]
      Normalized_counts_Annotated_mean[X_AXIS]=NULL
      Normalized_counts_Annotated_mean[X_AXIS]=NULL
      Normalized_counts_Annotated_mean$Row.names=NULL
      
      Heatmap_Normalized_counts_Annotated=Normalized_counts_Annotated
      rownames(Heatmap_Normalized_counts_Annotated)=make.unique(as.character(paste(unlist(Heatmap_Normalized_counts_Annotated[X_AXIS]),
                                                                                   unlist(Heatmap_Normalized_counts_Annotated['Row.names']))) ,
                                                                sep=' ')
      Heatmap_Normalized_counts_Annotated=Heatmap_Normalized_counts_Annotated[order(rownames(Heatmap_Normalized_counts_Annotated)),]
      Heatmap_Normalized_counts_Annotated[X_AXIS]=NULL
      Heatmap_Normalized_counts_Annotated[X_AXIS]=NULL
      row_names=Heatmap_Normalized_counts_Annotated$Row.names
      Heatmap_Normalized_counts_Annotated$Row.names=NULL
      row.names(Heatmap_Normalized_counts_Annotated)=row_names
    }
    Heatmap_Normalized_counts_Annotated = t(Heatmap_Normalized_counts_Annotated)
    Normalized_counts_Annotated_mean    = t(Normalized_counts_Annotated_mean)
    return(list(Normalized_counts_Annotated_mean,Heatmap_Normalized_counts_Annotated))
  }
}

cluster_Normalized_counts <- function(Normalized_counts_assay,opt){
  
  no_var=names(which( apply(Normalized_counts_assay,MARGIN = 1,FUN = sd)==0))
  if (length(no_var)>0){
    Normalized_counts_assay=Normalized_counts_assay[!(row.names(SPLIT_Normalized_counts_Annotated_mean)  %in% no_var),]
  }
  if (dim(Normalized_counts_assay)[1]>0){
    New_order= c()
    if ((opt$hc_metric=='spearman') | ((opt$hc_metric=='pearson') )){
      hc_metric='correlation'
    }else{
      hc_metric=opt$hc_metric
    }
    if (opt$stand){
      heat_map=pheatmap(mat = as.matrix(Normalized_counts_assay),
                        cluster_rows = T,show_rownames=F,
                        clustering_distance_rows = hc_metric ,
                        clustering_method=opt$hc_method,
                        cluster_cols = F,silent = T,scale = "row")
    }else{
      heat_map=pheatmap(mat = as.matrix(Normalized_counts_assay),
                        cluster_rows = T,show_rownames=F,
                        clustering_distance_rows = hc_metric ,
                        clustering_method=opt$hc_method,
                        cluster_cols = F,silent = T)
    }
    New_order =heat_map$tree_row$labels[heat_map$tree_row$order]
  }
  New_order = c(New_order,no_var)
  return(New_order)
}

Prepair_Normalized_counts_for_clustering <- function(Normalized_counts_assay,colData,opt){
  if (!is.na(opt$X_AXIS)){    
    X_AXIS=opt$X_AXIS
    if (is.na(opt$GROUP)){
      GROUP=X_AXIS
    }else{
      GROUP=opt$GROUP
    }
    if (X_AXIS!=GROUP){
      Normalized_counts_Annotated=merge(colData[c(X_AXIS,GROUP)],t(Normalized_counts_assay),all.x = T ,by="row.names",sort=F)
      Normalized_counts_Annotated_mean=aggregate.data.frame(x = Normalized_counts_Annotated,by = c(Normalized_counts_Annotated[GROUP],Normalized_counts_Annotated[X_AXIS]),FUN = mean)
      rownames(Normalized_counts_Annotated_mean)=paste(unlist(Normalized_counts_Annotated_mean[GROUP]),unlist(Normalized_counts_Annotated_mean[X_AXIS]))
      Normalized_counts_Annotated_mean=Normalized_counts_Annotated_mean[order(rownames(Normalized_counts_Annotated_mean)),]
      Normalized_counts_Annotated_mean$Row.names=NULL
      Normalized_counts_Annotated_mean[unique(c(X_AXIS,GROUP))]=NULL
      Normalized_counts_Annotated_mean[unique(c(X_AXIS,GROUP))]=NULL
      
      Heatmap_Normalized_counts_Annotated=Normalized_counts_Annotated
      rownames(Heatmap_Normalized_counts_Annotated)=make.unique(paste(unlist(Heatmap_Normalized_counts_Annotated[GROUP]),
                                                                      unlist(Heatmap_Normalized_counts_Annotated[X_AXIS]),
                                                                      unlist(Heatmap_Normalized_counts_Annotated['Row.names'])),
                                                                sep=' ')
      Heatmap_Normalized_counts_Annotated=Heatmap_Normalized_counts_Annotated[order(rownames(Heatmap_Normalized_counts_Annotated)),]
      Heatmap_Normalized_counts_Annotated[unique(c(X_AXIS,GROUP))]=NULL
      Heatmap_Normalized_counts_Annotated[unique(c(X_AXIS,GROUP))]=NULL
      row_names=Heatmap_Normalized_counts_Annotated$Row.names
      Heatmap_Normalized_counts_Annotated$Row.names=NULL
      row.names(Heatmap_Normalized_counts_Annotated)=row_names
      
    }else{
      Normalized_counts_Annotated=merge(colData[c(X_AXIS)],t(Normalized_counts_assay),all.x = T,by="row.names",sort=F)
      Normalized_counts_Annotated_mean=aggregate.data.frame(x = Normalized_counts_Annotated,by = Normalized_counts_Annotated[X_AXIS],FUN = mean)
      rownames(Normalized_counts_Annotated_mean)=unlist(Normalized_counts_Annotated_mean[X_AXIS])
      Normalized_counts_Annotated_mean=Normalized_counts_Annotated_mean[order(rownames(Normalized_counts_Annotated_mean)),]
      Normalized_counts_Annotated_mean[X_AXIS]=NULL
      Normalized_counts_Annotated_mean[X_AXIS]=NULL
      Normalized_counts_Annotated_mean$Row.names=NULL
      
      Heatmap_Normalized_counts_Annotated=Normalized_counts_Annotated
      rownames(Heatmap_Normalized_counts_Annotated)=make.unique(as.character(paste(unlist(Heatmap_Normalized_counts_Annotated[X_AXIS]),
                                                                                   unlist(Heatmap_Normalized_counts_Annotated['Row.names']))) ,
                                                                sep=' ')
      Heatmap_Normalized_counts_Annotated=Heatmap_Normalized_counts_Annotated[order(rownames(Heatmap_Normalized_counts_Annotated)),]
      Heatmap_Normalized_counts_Annotated[X_AXIS]=NULL
      Heatmap_Normalized_counts_Annotated[X_AXIS]=NULL
      row_names=Heatmap_Normalized_counts_Annotated$Row.names
      Heatmap_Normalized_counts_Annotated$Row.names=NULL
      row.names(Heatmap_Normalized_counts_Annotated)=row_names
    }
    Heatmap_Normalized_counts_Annotated = t(Heatmap_Normalized_counts_Annotated)
    Normalized_counts_Annotated_mean    = t(Normalized_counts_Annotated_mean)
    return(list(Normalized_counts_Annotated_mean,Heatmap_Normalized_counts_Annotated))
  }
}

cluster_Normalized_counts <- function(Normalized_counts_assay,opt){
  no_var=names(which( apply(Normalized_counts_assay,MARGIN = 1,FUN = sd)==0))
  if (length(no_var)>0){
    Normalized_counts_assay=Normalized_counts_assay[!(row.names(SPLIT_Normalized_counts_Annotated_mean)  %in% no_var),]
  }
  if (dim(Normalized_counts_assay)[1]>0){
    New_order= c()
    if ((opt$hc_metric=='spearman') | ((opt$hc_metric=='pearson') )){
      hc_metric='correlation'
    }else{
      hc_metric=opt$hc_metric
    }
    if (opt$stand){
      heat_map=pheatmap(mat = as.matrix(Normalized_counts_assay),
                        cluster_rows = T,show_rownames=F,
                        clustering_distance_rows = hc_metric ,
                        clustering_method=opt$hc_method,
                        cluster_cols = F,silent = T,scale = "row")
    }else{
      heat_map=pheatmap(mat = as.matrix(Normalized_counts_assay),
                        cluster_rows = T,show_rownames=F,
                        clustering_distance_rows = hc_metric ,
                        clustering_method=opt$hc_method,
                        cluster_cols = F,silent = T)
    }
    New_order =heat_map$tree_row$labels[heat_map$tree_row$order]
  }
  New_order = c(New_order,no_var)
  return(New_order)
}


test_diff <- function (se, type = c("control", "all", "manual"), control = NULL, 
          test = NULL, design_formula = formula(~0 + condition),pep_count = NULL) 
{
  library('purrr')
  library('limma')
  library('tibble')
  library('tidyr')
  library('SummarizedExperiment')
  library('DEqMS')
  library('matrixStats')
  
  assertthat::assert_that(inherits(se, "SummarizedExperiment"), 
                          is.character(type), class(design_formula) == "formula")
  type <- match.arg(type)
  col_data <- colData(se)
  raw <- assay(se)
  if (any(!c("name", "ID") %in% colnames(rowData(se, use.names = FALSE)))) {
    stop("'name' and/or 'ID' columns are not present in '", 
         deparse(substitute(se)), "'\nRun make_unique() and make_se() to obtain the required columns", 
         call. = FALSE)
  }
  if (any(!c("label", "condition", "replicate") %in% colnames(col_data))) {
    stop("'label', 'condition' and/or 'replicate' columns are not present in '", 
         deparse(substitute(se)), "'\nRun make_se() or make_se_parse() to obtain the required columns", 
         call. = FALSE)
  }
  if (any(is.na(raw))) {
    warning("Missing values in '", deparse(substitute(se)), 
            "'")
  }
  if (!is.null(control)) {
    assertthat::assert_that(is.character(control), length(control) == 
                              1)
    if (!control %in% unique(col_data$condition)) {
      stop("run test_diff() with a valid control.\nValid controls are: '", 
           paste0(unique(col_data$condition), collapse = "', '"), 
           "'", call. = FALSE)
    }
  }
  variables <- terms.formula(design_formula) %>% attr(., "variables") %>% 
    as.character() %>% .[-1]
  if (any(!variables %in% colnames(col_data))) {
    stop("run make_diff() with an appropriate 'design_formula'")
  }
  if (variables[1] != "condition") {
    stop("first factor of 'design_formula' should be 'condition'")
  }
  for (var in variables) {
    temp <- factor(col_data[[var]])
    assign(var, temp)
  }
  design <- model.matrix(design_formula, data = environment())
  colnames(design) <- gsub("condition", "", colnames(design))
  conditions <- as.character(unique(condition))
  if (type == "all") {
    cntrst <- apply(utils::combn(conditions, 2), 2, paste, 
                    collapse = " - ")
    if (!is.null(control)) {
      flip <- grep(paste("^", control, sep = ""), cntrst)
      if (length(flip) >= 1) {
        cntrst[flip] <- cntrst[flip] %>% gsub(paste(control, 
                                                    "- ", sep = " "), "", .) %>% paste(" - ", control, 
                                                                                       sep = "")
      }
    }
  }
  if (type == "control") {
    if (is.null(control)) 
      stop("run test_diff(type = 'control') with a 'control' argument")
    cntrst <- paste(conditions[!conditions %in% control], 
                    control, sep = " - ")
  }
  if (type == "manual") {
    if (is.null(test)) {
      stop("run test_diff(type = 'manual') with a 'test' argument")
    }
    assertthat::assert_that(is.character(test))
    if (any(!unlist(strsplit(test, "_vs_")) %in% conditions)) {
      stop("run test_diff() with valid contrasts in 'test'", 
           ".\nValid contrasts should contain combinations of: '", 
           paste0(conditions, collapse = "', '"), "', for example '", 
           paste0(conditions[1], "_vs_", conditions[2]), 
           "'.", call. = FALSE)
    }
    cntrst <- gsub("_vs_", " - ", test)
  }
  message("Tested contrasts: ", paste(gsub(" - ", "_vs_", cntrst), 
                                      collapse = ", "))
  fit <- lmFit(raw, design = design)
  made_contrasts <- makeContrasts(contrasts = cntrst, levels = design)
  contrast_fit <- contrasts.fit(fit, made_contrasts)
  if (any(is.na(raw))) {
    for (i in cntrst) {
      covariates <- strsplit(i, " - ") %>% unlist
      single_contrast <- makeContrasts(contrasts = i, levels = design[, 
                                                                      covariates])
      single_contrast_fit <- contrasts.fit(fit[, covariates], 
                                           single_contrast)
      contrast_fit$coefficients[, i] <- single_contrast_fit$coefficients[, 
                                                                         1]
      contrast_fit$stdev.unscaled[, i] <- single_contrast_fit$stdev.unscaled[, 
                                                                             1]
    }
  }
  eB_fit <- eBayes(contrast_fit,trend=TRUE)
  plotSA(eB_fit)
  # VarianceScatterplot(eB_fit, main = "Limma Variance")
  # DEqMS::VarianceBoxplot(eB_fit_PSM,n=30,main="Limma Variance Boxplot",xlab="PSM count")
  if (is.null(pep_count)){
      retrieve_fun <- function(comp, fit = eB_fit) {
        res <- topTable(fit, sort.by = "P", coef = comp, number = Inf, 
                        confint = TRUE)
        res <- res[!is.na(res$P), ]
        fdr_res <- fdrtool::fdrtool(res$P, plot = FALSE, verbose = FALSE,statistic="pvalue")
        res$qval <- fdr_res$qval
        res$lfdr <- fdr_res$lfdr
        res$comparison <- rep(comp, dim(res)[1])
        res <- rownames_to_column(res)
        return(res)
      }
      
      results = list()
      for (i in cntrst) {
        res = retrieve_fun(i,eB_fit)
        res =      res[,c("rowname","logFC","AveExpr","t","P.Value","adj.P.Val")]
        colnames(res)  = c("Gene","log2FoldChange","AveExpr","stat","pvalue","padj")
        row.names(res) = res$Gene
        results[i] = list(res)
      }
      # limma_res <- map_df(cntrst, retrieve_fun)
      # table <- limma_res %>% select(rowname, logFC, CI.L, CI.R, 
      #                              P.Value, qval, comparison) %>% mutate(comparison = gsub(" - ", 
      #                                                                                      "_vs_", comparison)) %>% gather(variable, value, -c(rowname, 
      #                                                                                                                                          comparison)) %>% mutate(variable = recode(variable, logFC = "diff", 
      #                                                                                                                                                                                    P.Value = "p.val", qval = "p.adj")) %>% unite(temp, comparison, 
      #                                                                                                                                                                                                                                  variable) %>% spread(temp, value)
      # rowData(se) <- merge(rowData(se, use.names = FALSE), table, 
      #                     by.x = "name", by.y = "rowname", all.x = TRUE, sort = FALSE)
      # return(se)
  }else{
    
    eB_fit_PSM = eB_fit
    eB_fit_PSM$count = pep_count[rownames(eB_fit_PSM$coefficients),"count"]
    DEqMS_fit = DEqMS::spectraCounteBayes(eB_fit_PSM)
    VarianceScatterplot(DEqMS_fit, main = "DEqMS Variance")
    results = list()
    for (i in cntrst) {
      res = outputResult(DEqMS_fit,coef_col = which(colnames(DEqMS_fit$coefficients)==i))
      # res = res[order(x = res$sca.P.Value),]
      # fdr_res <- fdrtool::fdrtool(res$sca.P.Value, plot = FALSE, verbose = FALSE,statistic="pvalue")
      res =      res[,c("gene","logFC","AveExpr","sca.t","sca.P.Value","sca.adj.pval")]
      colnames(res) = c("Gene","log2FoldChange","AveExpr","stat","pvalue","padj")
      results[i] = list(res)
    }
    
    
  }
  return(results)
}



create_excel_output <- function(se,results,opt, contrusts, output_path, linear_fc_cutoff, post_linear_fc_cutoff, alpha_cutoff, post_alpha,use_only_sig_gene=F,Annotation=NULL,Sig_Gene = c()){
  if(missing(linear_fc_cutoff) || is.na(linear_fc_cutoff)) {
    linear_fc_cutoff <- 1
  }
  if(missing(post_linear_fc_cutoff) || is.na(post_linear_fc_cutoff)) {
    post_linear_fc_cutoff <- 1
  }
  if(missing(alpha_cutoff) || is.na(alpha_cutoff)) {
    alpha_cutoff <- 0.05
  }
  if(missing(post_alpha) || is.na(post_alpha)) {
    post_alpha <- 0.05
  }
  
  LOG_FC_CUTOFF <- log(linear_fc_cutoff)
  manual_cutoff_formula = 'IF(AND(ISNUMBER(INDIRECT(ADDRESS(ROW(),COLUMN()-2))),INDIRECT(ADDRESS(ROW(),COLUMN()-2))<=FDR_CO,INDIRECT(ADDRESS(ROW(),COLUMN()-3))<=PVAL_CO,ABS(INDIRECT(ADDRESS(ROW(),COLUMN()-4)))>=LFC_CO),IF(INDIRECT(ADDRESS(ROW(),COLUMN()-4))>0,"up","down"),"")'
  manual_pass_any_beg = 'IF(OR(INDIRECT(ADDRESS(ROW(),COLUMN()-'
  manual_pass_any_conecter1 = '))="down", INDIRECT(ADDRESS(ROW(),COLUMN()-'
  manual_pass_any_mid = '))="down", INDIRECT(ADDRESS(ROW(),COLUMN()-'
  manual_pass_any_conecter2 = '))="up", INDIRECT(ADDRESS(ROW(),COLUMN()-'
  manual_pass_any_end = '))="up"),"yes","no")'
  manual_pass_any_one_col = 'IF(OR(INDIRECT(ADDRESS(ROW(),COLUMN()- 2))="down", INDIRECT(ADDRESS(ROW(),COLUMN()-2))="down", INDIRECT(ADDRESS(ROW(),COLUMN()-2))="up", INDIRECT(ADDRESS(ROW(),COLUMN()-2))="up"),"yes","no")'
  
  norm_counts <- SummarizedExperiment::assay(se)
   
  col_data    <- SummarizedExperiment::colData(se)

  Normalized_counts_Annotated = Prepair_Normalized_counts_for_clustering(norm_counts,col_data,opt)

  norm_counts = Normalized_counts_Annotated[[2]]

  Normalized_counts_For_clustering = Normalized_counts_Annotated[[1]]

  #New_oder = cluster_Normalized_counts(Normalized_counts_For_clustering,opt)

  #norm_counts = norm_counts[New_oder,]

  
  res_dim2 <- 5 # Columns per contrast in res_df: linearFC, pvalue, padj and pass
  digits = 10
  ### Add preamble: gene name and counts
  res_df = data.frame(gene = rownames(norm_counts),
                      norm_counts)
  # Save header info:
  res_df_compar_head = c("Gene",rep("Normalized Intensity",dim(col_data)[1]))  
  # Save widths of data groups:
  res_df_grouping <- c(1,dim(norm_counts)[2])
  
  #contr_list <- resultsNames(dds)[-1]
  if (length(contrusts)>0){
    #print(contrusts)
    pass_man_cols = seq(from=2, length.out=length(contrusts), by = 5)
    pass_man_cols_values = rep(pass_man_cols, each = 2)
    ### Add statistical tables
    for (CONTRAST in contrusts) {
      contrast_list = unlist(stringi::stri_split(str =  CONTRAST,regex = ','))
      if (length(contrast_list)==2){
          compar_print_name = paste(contrast_list[1],contrast_list[2],sep = '_vs_')
          contrast_list = as.list(contrast_list)
      }else{
          compar_print_name = paste(contrast_list[2],contrast_list[3],sep = '_vs_')
      }
      
      cat(paste0("Adding contrust: ", compar_print_name, "\n"))
      res_df <-
        results[[compar_print_name]]  %>% 
        as_tibble %>% 
        # mutate(basemeans = round(baseMean,digits = 2)) %>% 
        dplyr::mutate(linearFC = ifelse(is.na(log2FoldChange),
                                        yes = NA,
                                        no = ifelse(log2FoldChange>0,
                                                    yes = 2^log2FoldChange,
                                                    no = -1/(2^log2FoldChange))%>% 
                                          signif(digits = digits))) %>% 
        dplyr::mutate(pvalue = ifelse(test = is.na(pvalue),
                                      yes = NA,
                                      no = signif(pvalue,digits = digits))) %>% 
        dplyr::mutate(padj = ifelse(test = is.na(padj),
                                    yes = NA,
                                    no = signif(padj,digits = digits))) %>% 
        dplyr::mutate(pass = ifelse(test = abs(as.numeric(linearFC)) >= linear_fc_cutoff & 
                                      padj <= alpha_cutoff & 
                                      !is.na(padj),
                                    yes = ifelse(test = as.numeric(linearFC)>0,
                                                 yes="up",
                                                 no="down"),
                                    no = "")) %>%
        dplyr::mutate(manual_cutoffs = manual_cutoff_formula) %>%
        dplyr::select(Gene,linearFC,pvalue,padj,pass,manual_cutoffs) %>%
        as.data.frame  %>% 
        merge.data.frame(x = res_df,y = .,by.x = 'gene' ,by.y = 'Gene',all.x = T)
        row.names(res_df) = res_df$gene
        res_df$Gene=NULL
        
      colnames(res_df)[colnames(res_df)=="linearFC"] <- paste0("linearFC.",compar_print_name)
      colnames(res_df)[colnames(res_df)=="pvalue"] <- paste0("pvalue.",compar_print_name)
      colnames(res_df)[colnames(res_df)=="padj"] <- paste0("padj.",compar_print_name)
      colnames(res_df)[colnames(res_df)=="pass"] <- paste0("pass.",compar_print_name)
      colnames(res_df)[colnames(res_df)=="manual_cutoffs"] <- paste0("manual_cutoffs.",compar_print_name)
      
      res_df_compar_head <- c(res_df_compar_head,
                              rep(compar_print_name,
                                  res_dim2))
      # Add width of group to res_df_grouping
      res_df_grouping <- c(res_df_grouping,res_dim2)
    }
  }
  ## Additional columns - Add pass_any field
  # pass_any = TRUE if any contrast pass value is 1
  # Do only is there are more than one 'pass' column (not in Scales)
  if (sum(stringr::str_detect(string = names(res_df),
                              pattern = "pass")) >1 ) {
    
    # adding the pass any column
    res_df$pass_any <-
      apply(X = res_df[,stringr::str_detect(string = names(res_df),
                                            pattern = "pass")],
            MARGIN = 1,
            FUN = function(x) any(unlist(x)!=""))
    Sig_Gene = row.names(res_df[res_df$pass_any,])
    # Convert TRUE/FALSE to YES/NO"":
    res_df$pass_any <- ifelse(test = !is.na(res_df$pass_any) & res_df$pass_any==TRUE,
                              yes = "yes",
                              no = "no")
    res_df_grouping <- c(res_df_grouping,1)
    res_df_compar_head <- c(res_df_compar_head, "pass_any")
    names(res_df) <- make.names(names(res_df),
                                unique = T)   
    
    # adding the manual pass any
    part1 <- str_c(pass_man_cols, collapse = manual_pass_any_conecter1)
    part2 <- str_c(pass_man_cols, collapse = manual_pass_any_conecter2)
    #total_formula <- paste0(manual_pass_any_beg, part1, manual_pass_any_mid, part2, manual_pass_any_end)
    
    res_df$pass_any_manual <- paste0(manual_pass_any_beg, part1, manual_pass_any_mid, part2, manual_pass_any_end)
    
    res_df_grouping <- c(res_df_grouping,1)
    res_df_compar_head <- c(res_df_compar_head, "pass_any_manual")
    
  } else if (sum(stringr::str_detect(string = names(res_df),
                                     pattern = "pass")) ==1 ) {
    
    # adding the pass any column
    res_df$pass_any <- ifelse(test = res_df[,stringr::str_detect(string = names(res_df),pattern = "pass")]!="",
                              yes = "yes",
                              no = "no")
    Sig_Gene = row.names(res_df[res_df$pass_any=='yes',])
    res_df_grouping <- c(res_df_grouping,1)
    res_df_compar_head <- c(res_df_compar_head, "pass_any")
    names(res_df) <- make.names(names(res_df),
                                unique = T)  
    
    # adding the manual pass any column
    res_df$pass_any_manual <- manual_pass_any_one_col
    
    res_df_grouping <- c(res_df_grouping,1)
    res_df_compar_head <- c(res_df_compar_head, "pass_any_manual")
  }

  if ((use_only_sig_gene)&(length(Sig_Gene)>0)) {
    if (length(Sig_Gene)>1){
        order_genes = cluster_Normalized_counts(Normalized_counts_For_clustering[Sig_Gene,],opt)
    }else{
        order_genes = Sig_Gene
    }
    #order_genes = cluster_Normalized_counts(norm_counts[Sig_Gene,],opt)
    Cluster_Order = 1:length(order_genes)
    order_genes = data.frame(row.names = order_genes,Cluster_Order)
    
    res_df = res_df[Sig_Gene,]  
    res_df = merge.data.frame(x = res_df,y = order_genes,by.x = 'gene' ,by.y = 'row.names',all.x = T)
    res_df$Row.names=NULL
    res_df_grouping <- c(res_df_grouping,1)
    res_df_compar_head <- c(res_df_compar_head, "Sort for Clustering")
    
    res_df = merge.data.frame(x = res_df,y = t(scale(t(norm_counts))),by.x = 'gene' ,by.y = 'row.names',all.x = T)
    res_df$Row.names=NULL
    res_df_compar_head = c(res_df_compar_head,rep("Z score",dim(norm_counts)[2]))  
    res_df_grouping <- c(res_df_grouping,dim(norm_counts)[2])
  }
  if (!is.na(Annotation)){
    res_df = merge.data.frame(x = res_df,y = Annotation,by.x = 'gene' ,by.y = 'row.names',all.x = T)
    res_df$Row.names=NULL
    res_df_compar_head = c(res_df_compar_head,rep("Annotation",dim(Annotation)[2]))  
    res_df_grouping <- c(res_df_grouping,dim(Annotation)[2])
  }
  ## Output to excel
  ### Prepare data to write:
  
  # index in res_df_grouping for which to produce column info above the table (2=counts data)
  res_df_grouping_meta <- c(2)
  res_df2write = res_df
  
  res_df_formula_columns <-
    res_df2write %>%
    names %>%
    stringr::str_detect(pattern = "manual") %>%
    which
  
  for (coli in res_df_formula_columns) {
    class(res_df2write[,coli]) <- c(class(res_df2write[,coli]), "formula")
  }
  
  # In case these have been expanded below, keeping only the part from res_df:
  res_df_compar_head <- res_df_compar_head[1:ncol(res_df)]
  res_df_grouping <- res_df_grouping[cumsum(res_df_grouping) <= ncol(res_df)]
  
  ### Output main table
  # Writing data to an excel workbook:
  wb <- createWorkbook()
  cat("Creating workbook\n")
  
  # Adding cutoffs form
  addWorksheet(wb, 
               sheetName = "Cutoffs", 
               gridLines = TRUE)
  writeData(wb, "Cutoffs", 
            x = c("p-value","Adjusted pvalue (FDR)","linear Fold Change (linearFC)"), 
            startCol = 1, 
            startRow = 4)
  writeData(wb, "Cutoffs", 
            x = c(alpha_cutoff, post_alpha, post_linear_fc_cutoff), 
            startCol = 2, 
            startRow = 4)
  createNamedRegion(wb, "Cutoffs", cols=2, rows=4, "PVAL_CO")
  createNamedRegion(wb, "Cutoffs", cols=2, rows=5, "FDR_CO")
  createNamedRegion(wb, "Cutoffs", cols=2, rows=6, "LFC_CO")
  
  style_COs <- 
    createStyle(border = "TopBottomLeftRight",
                # borderColour = getOption("openxlsx.borderColour", "black"),
                borderStyle = "thick", 
                fgFill = "yellow")
  addStyle(wb, "Cutoffs", style_COs, rows=4:6, cols=2, gridExpand = FALSE, stack = FALSE)
  
  # Add worksheet and data:
  addWorksheet(wb, 
               sheetName = "Statistics", 
               gridLines = TRUE)
  writeDataTable(wb, 
                 sheet = "Statistics", 
                 x = res_df2write,
                 startRow = 2,
                 colNames = TRUE,
                 rowNames = FALSE,
                 tableStyle = "TableStyleLight9")
  
  s_num_cs_round <- createStyle(numFmt = "#,##0")
  addStyle(wb, 
           sheet = "Statistics", 
           style =  s_num_cs_round, 
           rows = (2):(1+dim(res_df2write)[1]), 
           cols = (res_df_grouping[1]+1):sum(res_df_grouping[1:2]), 
           gridExpand = TRUE, stack = FALSE)
  # Adding additional column information above column headers
  writeData(wb, 
            sheet = "Statistics", 
            x = res_df_compar_head %>% as.matrix %>% t,
            startRow = 1,
            colNames = F,
            rowNames = F)
  
  ###############
  # 1. Create style
  # 2. Add style to location
  # Creating `colorscheme` with background colors and appropriate text color, based on luminence (brightness)
  
  mycolors = rep(brewer.pal(11, name = "Spectral"),3)
  colorscheme <- data.frame(colnum = res_df_grouping,
                            fgcol= mycolors[1:length(res_df_grouping)],
                            stringsAsFactors = F)
  colorscheme$textcol <- ifelse((as(hex2RGB(colorscheme$fgcol),"polarLUV"))@coords[,1] > 65, 
                                yes = "dimgray",
                                no = "white")
  
  for (i in 1:length(res_df_grouping)) {
    cat(sprintf("%s of %s\n",i,length(res_df_grouping)))
    # Add title color:
    hs1 <- createStyle(fgFill = colorscheme$fgcol[i], 
                       fontColour = colorscheme$textcol[i])
    addStyle(wb, 
             sheet = "Statistics", 
             style =  hs1, 
             rows = 2, 
             cols = ifelse(i==1,1,cumsum(res_df_grouping)[i-1]+1):cumsum(res_df_grouping)[i], 
             gridExpand = FALSE, stack = TRUE)
    # Add group separator:
    hs2 <- createStyle(border = "Right",
                       borderColour = "black",
                       borderStyle = "thick")
    addStyle(wb = wb, 
             sheet = "Statistics", 
             style = hs2, 
             rows = (3):(1+dim(res_df2write)[1]), 
             cols = cumsum(res_df_grouping)[i], 
             gridExpand = FALSE, stack = TRUE)
    
  }
  
  # Writing workbook:
  saveWorkbook(wb, 
               file = sprintf(paste0(output_path, ".xlsx")), 
               overwrite = TRUE) ## save to working directory
  write.csv(res_df2write,file = sprintf(paste0(output_path, ".csv")))
  return(Sig_Gene)
}

create_pathway_table <- function(outDir,up_reg,down_reg,Annotation,Pathway2name,Pathway2gene,show_cutoff=1,HTML=T,up_color='HotPink',down_color='DeepSkyBlue',useKO=T, Base_URL = "https://www.kegg.jp/pathway/"){
  
  
  if ((length(down_reg)>0) || (length(up_reg)>0)){
    kegg_id=''
    if (('KEGG' %in% stringr::str_to_upper(colnames(Annotation))) & (useKO==F) ){
      kegg_id =colnames(Annotation)[which('KEGG' == stringr::str_to_upper(colnames(Annotation)))[1]]
    }else{
      if ('KO' %in% stringr::str_to_upper(colnames(Annotation))){
        kegg_id =colnames(Annotation)[which('KO' == stringr::str_to_upper(colnames(Annotation)))[1]]
      }
    }
    if (kegg_id!=''){
      Annotation2USE=Annotation
      Annotation2USE['row.names'] = row.names(Annotation2USE)
      gene2Kegg = convert_agregate(Annotation2USE,'row.names',kegg_id,"/")
      colnames(gene2Kegg) = c('Gene','Kegg')
      Pathway2gene = merge.data.frame(x =Pathway2gene,y = Pathway2name,by.x = colnames(Pathway2gene)[1] ,by.y = colnames(Pathway2name)[1])
      Pathway2gene[,1] = unlist(stringr::str_remove(string = Pathway2gene[,1],pattern = '.+:'))
      genes = c(up_reg,down_reg)
      Pathway2gene_filterd = Pathway2gene[Pathway2gene[,2] %in% genes,]
      colnames(Pathway2gene_filterd) = c('Pathway','Gene','Info')
      if (dim(Pathway2gene_filterd)[1]>0){
        Pathway2gene_filterd = merge.data.frame(x = Pathway2gene_filterd,y = gene2Kegg,by = 'Gene',all.x = T)
        colnames(Pathway2gene_filterd) = c('Gene','Pathway','Info','Kegg')
        UP = Pathway2gene_filterd[,'Gene'] %in% up_reg
        if (sum(UP)>0){
          Pathway2gene_filterd[UP,"URL"] = paste(Pathway2gene_filterd[UP,'Kegg'] , up_color ,sep = ' ')     
        }
        DOWN = Pathway2gene_filterd[,'Gene'] %in% down_reg
        if (sum(DOWN)>0){
          Pathway2gene_filterd[DOWN,"URL"] = paste(Pathway2gene_filterd[DOWN,'Kegg'] , down_color ,sep = ' ')     
        }
        Pathway2gene_count = aggregate.data.frame(x = Pathway2gene_filterd[,'Kegg'], by = list(Pathway2gene_filterd[,'Pathway']),FUN = length )
        colnames(Pathway2gene_count) = c('Pathway','#Genes')
        Pathway = aggregate.data.frame(x =Pathway2gene_filterd ,
                                       by = list(Pathway2gene_filterd[,'Pathway']),
                                       FUN =function(x) paste(unique(na.omit(x)),sep = "+",collapse = "+"))
        Pathway['Base_URL'] = Base_URL
        
        Pathway[,'Kegg_URL'] = apply(X = Pathway,MARGIN = 1,FUN = function(x) paste(x['Base_URL'],x['Pathway'],sep = '',collapse = ''))
        Pathway[,'Kegg_URL'] = apply(X = Pathway,MARGIN = 1,FUN = function(x) paste(x['Kegg_URL'],x['URL'],sep = '+',collapse = '+'))
        
        
        Pathway = merge.data.frame(x = Pathway,y = Pathway2gene_count,by = "Pathway" )
        row.names(Pathway) = Pathway$Pathway
        Pathway = Pathway[Pathway[,'#Genes']>=show_cutoff,c("Info","#Genes","Kegg_URL","Gene","Kegg")]
        Pathway =Pathway[order(Pathway[,'#Genes'],decreasing = T), ]
        write.table(Pathway,
                    file = file.path(outDir,paste('Kegg_Pathways_Links_With_Min_of',show_cutoff,'genes.tab', sep = '_')) ,
                    quote = F,
                    sep = "\t")
        if (HTML){
          Pathway[,'Kegg_URL'] = apply(X = Pathway,MARGIN = 1,FUN = function(x) paste('<a href="',x['Kegg_URL'],'" target="_blank">View Pathway</a>',sep = '',collapse = ''))
        }
        return(Pathway)  
      }else{
        return(data.frame())
      } 
    }else{
        return(data.frame())
    }
  }else{
    return(data.frame())
  }
}

Filter_Pathways_By_Taxa <- function(taxon){
    ko_paths_names_all = KEGGREST::keggList("pathway", "ko")
    kegg_organisms     = KEGGREST::keggList("organism")
    kegg_organisms     = as.data.frame(kegg_organisms)
    organisms          = kegg_organisms[str_detect(kegg_organisms$phylogeny,taxon),'organism']
    
    paths = c()  #initialize paths vector
    for (org in organisms) {
        a = unique(KEGGREST::keggLink("pathway", org))  #get all pathways per species, make the list nonredundant
        print (paste (org, length(a), "pathways"))
        a = str_replace(a, "path:[a-z]+", "path:ko")  #replace species-specific with ko path name
        paths = c(paths, a)  #add to paths vector
    }
    paths_unique = unique(paths)  #remove redundancy
    print (paste ("No of unique KO pathways retrieved:", length(paths_unique)))
    paths_unique = str_replace(paths_unique, "ko", "map")
    return(paths_unique)
}
#####################Functions-End################################

#####################Read count data and pars it##################
pep.count.table  = NULL
Selected_columns = NULL
if (opt$ProteinGroups_SOURCE=='LFQ'){
  print('Reading ProteinGroups Data..')
  ProteinGroupsData <- read.delim(file = opt$ProteinGroups_DATA_FILE)
  ProteinGroupsData <- filter(ProteinGroupsData, Reverse != "+", Potential.contaminant != "+")
  ProteinGroupsData <- make_unique(ProteinGroupsData, "Gene.names", "Protein.IDs", delim = ";")
  Selected_columns  <- grep("LFQ.", colnames(ProteinGroupsData))
  if (opt$USEDEqMS){
    pep.count_columns <- grep("Razor...unique.peptides.", colnames(ProteinGroupsData)) 
    pep.count.table = data.frame(count = rowMins(as.matrix(ProteinGroupsData[,pep.count_columns])),
                             row.names = ProteinGroupsData$name)
    # Minimum peptide count of some proteins can be 0
    # add pseudocount 1 to all proteins
    pep.count.table$count = pep.count.table$count+1
  }
  print('Done reading ProteinGroups Data')
} else if (opt$ProteinGroups_SOURCE=='MATRIX'){
  ProteinGroupsData <- read.delim(file = opt$ProteinGroups_DATA_FILE)
  Selected_columns = c(2:length(colnames(ProteinGroupsData)))
  colnames(ProteinGroupsData)[1] = 'ID'
  ProteinGroupsData[,Selected_columns] = apply(ProteinGroupsData[,Selected_columns],
                                             c(1,2),function(x) as.numeric(gsub(",", "", x)))
  ProteinGroupsData$ID =  unlist(lapply(X =ProteinGroupsData$ID,FUN = function(x) stringi::stri_split(str = x,fixed = ' ')[[1]][1]))
  ProteinGroupsData$name = ProteinGroupsData$ID

}

if (!is.na(opt$SAMPLE_DATA_FILE)){
  
  print('Reading Experimental Design Data..')
  
  experimental_design <- read.delim(file = opt$SAMPLE_DATA_FILE )
  if (!('label' %in% colnames(experimental_design))){
    colnames(experimental_design)[1] = 'label'
  }
  
  if (!('condition' %in% colnames(experimental_design))){
    stop("A column named 'condition' must be in the experimental design file")
  }
  
  if (!('replicate' %in% colnames(experimental_design))){
    experimental_design['replicate'] = 1
    for (condition in unique(experimental_design['condition']) ){
        row2use = experimental_design$condition == condition
        experimental_design[row2use,'replicate'] = c(1:sum(row2use))
    }
  }
  used_samples = experimental_design$label
  if (!is.na(opt$SUBSET_SAMPLES)) {
     sub_samples = unlist(stringi::stri_split(str = opt$SUBSET_SAMPLES,fixed = ','))
     used_samples = intersect(used_samples, sub_samples)
  }

  if (!is.na(opt$EXCLUDE_SAMPLES)) {
     exclude_samples = unlist(stringi::stri_split(str = opt$EXCLUDE_SAMPLES,fixed = ','))
     used_samples = setdiff(used_samples, exclude_samples)
  }

    if (!is.na(opt$PCA_SIZE)){
        if (!is.numeric(experimental_design[opt$PCA_SIZE])){
           PCA_SIZE = paste(opt$PCA_SIZE,'_',sep='')
           experimental_design[PCA_SIZE] = as.numeric(factor(experimental_design[[opt$PCA_SIZE]]))
           opt$PCA_SIZE = PCA_SIZE
        }
    }else{
        opt$PCA_SIZE = 'PCA_SIZE_'
        experimental_design[opt$PCA_SIZE] = 2
    }

  experimental_design = experimental_design[experimental_design$label %in% used_samples,]
  ProteinGroupsData_SE <- make_se( ProteinGroupsData , Selected_columns, experimental_design)
  countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
 
  print('Done Experimental Design Data')
  
}

Annotation_flag = ''
keggConv_id_type = "uniprot"
Annotation_file=file.path(opt$outDir,paste('Annotation','tab', sep = '.'))

GO2gene_MF = NA
GO2name_MF = NA

GO2gene_BP = NA
GO2name_BP = NA

GO2gene_CC = NA
GO2name_CC = NA


if  (!file.exists(Annotation_file)){
#Get Annotation
    Annotation = NA
    if (!is.na(opt$Annotation_db) ){
      
      # Check if required packages are installed:
      if(!(all(c(opt$Annotation_db) %in% installed.packages()))) {
        if (Sys.getenv("CONDA_PREFIX")!=""){
          source("https://bioconductor.org/biocLite.R")
          biocLite(opt$Annotation_db)
          library(opt$Annotation_db,character.only =T)
        }else{
          cat("The Bioconductor Annotation Data Base package is not installed. You must install it for this script to work!")
        }
      }else{
        library(opt$Annotation_db,character.only =T)  
      } 
      
      if (paste("package:",opt$Annotation_db,sep='') %in% search()){
        Annotation=bitr(rownames(countData), fromType=opt$GENE_ID_TYPE, toType=c("ENTREZID",'UNIPROT',"GO","ONTOLOGY","GENENAME","PATH","SYMBOL","PFAM"), OrgDb=opt$Annotation_db)
        Annotation$kegg= sapply(X = Annotation$PATH,FUN = function(X) paste('path:map',x,sep='' ) )
        Annotation_flag = 'OrgDb'
      }
    }
    
    if (is.na(Annotation)) {
        if (!is.na(opt$Species)){
            if(!(all(c('AnnotationHub') %in% installed.packages()))) {
                if (Sys.getenv("CONDA_PREFIX")!=""){
                    source("https://bioconductor.org/biocLite.R")
                    biocLite('AnnotationHub')
                    library('AnnotationHub',character.only =T)
                  }else{
                    cat("The Bioconductor AnnotationHub Annotation package is not installed. You must install it for this script to work!")
                  }
                }else{
                  library('AnnotationHub',character.only =T)  
                } 
            
            if(!(all(c('ensembldb') %in% installed.packages()))) {
                if (Sys.getenv("CONDA_PREFIX")!=""){
                    source("https://bioconductor.org/biocLite.R")
                    biocLite('ensembldb')
                    library('ensembldb',character.only =T)
                  }else{
                    cat("The Bioconductor ensembldb Annotation package is not installed. You must install it for this script to work!")
                  }
                }else{
                  library('ensembldb',character.only =T)  
                } 
            
            if ( ("package:AnnotationHub" %in% search())&("package:ensembldb" %in% search()) ){
                cache = file.path(opt$outDir,'cache')
                dir.create(cache, showWarnings = T)
                ah  = AnnotationHub(cache = cache )
                Hub = query(ah, c('OrgDb'))
                species = unique(Hub$species)
                
                dataset = species[(sapply(X = species,FUN = function(X) stringi::stri_startswith(fixed =  stringi::stri_trans_tolower(opt$Species),str =  stringi::stri_trans_tolower(X)    )))]
                if (length(dataset) > 0) {
                    dataset = dataset[1]
                    print('Found Species:')
                    print(dataset)
                    Hub = query(ah, c('OrgDb',dataset))
                    Hub = Hub[[length(Hub$title)]]
                    Hub_columns = columns(Hub)
                    fields2use  = c('GENENAME','SYMBOL','PFAM') 
                    print('Cloumns in DB:')
                    print(Hub_columns)
                    if (is.na(opt$GENE_ID_TYPE)){
                        genes  = rownames(countData)
                        max_overlap = list()
                        for (col in Hub_columns){
                            if (sum(stringi::stri_startswith(fixed =col  ,str = Hub_columns))<2){
                                max_overlap[col] = length(intersect(genes,keys(Hub, keytype=col)))
                            }
                        }
                        GENE_ID_TYPE = names(max_overlap)[max_overlap == max(unlist(max_overlap))]
                        if (length(GENE_ID_TYPE)>0 ){
                            opt$GENE_ID_TYPE = GENE_ID_TYPE[1]
                            print('Gene ID That Was Chosen:')
                            print(opt$GENE_ID_TYPE)
                        }
                    }
                    if ( stringi::stri_trans_toupper(opt$GENE_ID_TYPE) %in% columns(Hub)){
                        if (opt$USE_INPUT_GENES_AS_BACKGROUND){
                            Genes  = rownames(countData)
                        } else {
                            Genes  = keys(Hub, keytype=stringi::stri_trans_toupper(opt$GENE_ID_TYPE))
                        }
                        
                        # Genes  = keys(Hub, keytype=stringi::stri_trans_toupper(opt$GENE_ID_TYPE))
                        if (('GOALL' %in% Hub_columns) & ('GO' %in% Hub_columns) ){
                            fields2use = c(fields2use,'GOALL')
                        }else{
                            fields2use = c(fields2use,'GO')
                        }
                        Annotation  = select(Hub,
                                             keys = as.character(Genes),
                                             columns=intersect(Hub_columns, fields2use),
                                             keytype=stringi::stri_trans_toupper(opt$GENE_ID_TYPE))
                        print(dim(Annotation))
                        if ('GO' %in% Hub_columns) {
                            colnames(Annotation)['GO'    == colnames(Annotation)] = 'go_id'
                        }
                        if ('GOALL' %in% Hub_columns) {
                            colnames(Annotation)['GOALL' == colnames(Annotation)] = 'go_id'
                        }
                        if ('UNIPROT' %in% Hub_columns) {
                            Kegg_Annotation = select(Hub,
                                                 keys = as.character(Genes),
                                                 columns=intersect(Hub_columns, c('UNIPROT')),
                                                 keytype=stringi::stri_trans_toupper(opt$GENE_ID_TYPE))
                            colnames(Kegg_Annotation) = c(stringi::stri_trans_toupper(opt$GENE_ID_TYPE),keggConv_id_type)
                            Kegg_Annotation = Kegg_Annotation[!is.na(Kegg_Annotation[,keggConv_id_type]),]
                        }else if ('GID' %in% Hub_columns){
                            Kegg_Annotation = select(Hub,
                                                 keys = as.character(Genes),
                                                 columns=intersect(Hub_columns, c('GID')),
                                                 keytype=stringi::stri_trans_toupper(opt$GENE_ID_TYPE))
                            keggConv_id_type = 'ncbi-geneid'
                            colnames(Kegg_Annotation) = c(stringi::stri_trans_toupper(opt$GENE_ID_TYPE),keggConv_id_type)
                            Kegg_Annotation = Kegg_Annotation[!is.na(Kegg_Annotation[,keggConv_id_type]),]
                        }
                        opt$Species      = dataset
                        Annotation_flag  = 'ensembl'
                        opt$GENE_ID_TYPE = stringi::stri_trans_toupper(opt$GENE_ID_TYPE)
                        
                    }else{
                        print('Could not find your Gene Type ID, These are the available options:')
                        print(columns(Hub))
                    }
                }
                unlink(cache,recursive=TRUE)
            }
        }
    }
     
    
    if (is.na(Annotation)) {
      if (!is.na(opt$Species)){
        # Check if required packages are installed:
        if(!(all(c('biomaRt') %in% installed.packages()))) {
          if (Sys.getenv("CONDA_PREFIX")!=""){
            source("https://bioconductor.org/biocLite.R")
            biocLite('biomaRt')
            library('biomaRt',character.only =T)
          }else{
            cat("The Bioconductor biomaRt Annotation package is not installed. You must install it for this script to work!")
          }
        }else{
          library('biomaRt',character.only =T)  
        } 
        
        if ("package:biomaRt" %in% search()){
          dataset=c()
          try_count=0
          mirror = "useast"
          while ((length(dataset) == 0)&&(try_count<10) ){
            try_count = try_count+1
            host = "www.ensembl.org"#
            Test_host<-try(biomaRt::listMarts(host=host),silent = T)
            if (inherits(Test_host,"try-error")){
              host = "apr2019.archive.ensembl.org"
            }
            biomart = "ensembl"
            M=biomaRt::useMart(biomart = biomart, host = host)
            ensembl_dataset = biomaRt::listDatasets(M)
            dataset= ensembl_dataset$dataset[(sapply(X = ensembl_dataset$description,FUN = function(X) stringi::stri_startswith(fixed =  stringi::stri_trans_tolower(opt$Species),str =  stringi::stri_trans_tolower(X)    )))]
            print(dataset)
            if (length(dataset) == 0){
              list_dataset=unlist(stringi::stri_split(str = unlist(stringi::stri_split(str =  unlist( t(ensembl_dataset) ),regex = '\n \nTableSet\t')),regex = '\t'))
              dataset<-try( list_dataset[which(stringi::stri_startswith(str = stringi::stri_trans_tolower(list_dataset),fixed = stringi::stri_trans_tolower(opt$Species)))-1],silent = T) 
              if (inherits(Test_host,"try-error")){
                dataset=''
              }
            }
            
            if (length(dataset) == 0){
              host = "www.plants.ensembl.org"
              Test_host<-try(biomaRt::listMarts(host=host),silent = T)
              if (inherits(Test_host,"try-error")){
                host = "plants.ensembl.org"
              }
              biomart = 'plants_mart'
              M=biomaRt::useMart(biomart = biomart,host = host)
              plant=biomaRt::listDatasets(M)
              dataset= plant$dataset[(sapply(X = plant$description,FUN = function(X) stringi::stri_startswith(fixed =  stringi::stri_trans_tolower(opt$Species),str =  stringi::stri_trans_tolower(X)    )))]
            }
            if (length(dataset) == 0){
              list_dataset=unlist(stringi::stri_split(str = unlist(stringi::stri_split(str =  unlist( t(plant) ),regex = '\n \nTableSet\t')),regex = '\t'))
              dataset<-try( list_dataset[which(stringi::stri_startswith(str = stringi::stri_trans_tolower(list_dataset),fixed = stringi::stri_trans_tolower(opt$Species)))-1],silent = T) 
              if (inherits(Test_host,"try-error")){
                dataset=c()
              }
            }
            
            if (length(dataset) == 1){
                try_count2 =0
                if (biomart == 'plants_mart'){
                     ensembl <- try(biomaRt::useEnsemblGenomes(biomart=biomart, dataset=as.character(dataset)),silent = T)
                } else{
                     ensembl <-  try(biomaRt::useEnsembl(biomart=biomart, dataset=as.character(dataset),host = host,mirror=mirror),silent = T)
                }
                while ((inherits(ensembl,"try-error")) &&( try_count2<3) ){
                  try_count2 = try_count2+1
                  if (biomart == 'plants_mart'){
                     ensembl <- try(biomaRt::useEnsemblGenomes(biomart=biomart, dataset=as.character(dataset)),silent = T)
                  } else{
                     ensembl <- try(biomaRt::useEnsembl(biomart=biomart, dataset=as.character(dataset),host = host,mirror=mirror),silent = T)
                  }
                }
                if (inherits(ensembl,"try-error")){
                  dataset=c()
                }
                
            }
          }
          
          if (length(dataset)==1){
            print('Found Species:')
            print(dataset)
            if ( opt$GENE_ID_TYPE %in% biomaRt::listAttributes(ensembl)$name){
              Total_Annotation = c()
              if (opt$USE_INPUT_GENES_AS_BACKGROUND){
                genes <- rownames(countData)
              } else {
                genes <- getBM(attributes = opt$GENE_ID_TYPE, mart = ensembl)
              }
              
              # genes <- getBM(attributes = opt$GENE_ID_TYPE, mart = ensembl)
              attributes=c( 'go_id',
                            'namespace_1003')
              if (!opt$GENE_ID_TYPE %in% attributes){
                attributes = c(opt$GENE_ID_TYPE,attributes)
              }
              for (subset_genes in split(genes[,opt$GENE_ID_TYPE], ceiling(seq_along(genes[,opt$GENE_ID_TYPE] )/10000))){
                # subset_genes   = genes[,opt$GENE_ID_TYPE]
                getBM_count    = 1
                max_getBM_trys = 100
                while (getBM_count<max_getBM_trys){
                    print(getBM_count)
                    Annotation = try(getBM(values = subset_genes,
                                        filters = opt$GENE_ID_TYPE,
                                        attributes = attributes,
                                        uniqueRows = TRUE,
                                        mart = ensembl),silent = T)
                                        
                    if (!inherits(Annotation,"try-error")){
                        Total_Annotation = rbind(Total_Annotation,Annotation)
                        getBM_count = max_getBM_trys
                    }
                    getBM_count = getBM_count + 1
                }
                if (inherits(Annotation,"try-error")){
                    stop()
                }
              }
              getBM_count=1
              max_getBM_trys = 20
              while (getBM_count<max_getBM_trys){
                  print(getBM_count)
                  biotype = try(getBM(attributes = c(opt$GENE_ID_TYPE,
                                             'external_gene_name',
                                             'gene_biotype',
                                             'description'
                                                    ),
                                       uniqueRows = TRUE,
                                       mart = ensembl),silent = T)
                 if (!inherits(biotype,"try-error")){
                     getBM_count = max_getBM_trys
                 }
                    getBM_count = getBM_count + 1  
              }
              
              if (inherits(biotype,"try-error")){
                 stop()
              }
              
              Total_Annotation=merge.data.frame(x = Total_Annotation,y = biotype,by = opt$GENE_ID_TYPE,all = T)
              Annotation = Total_Annotation
              # Annotation$kegg = sapply(X = Annotation$kegg_enzyme,FUN = function(X) unlist(stringi::stri_split(str = X,fixed  = '+'))[1] )
              #Annotation$kegg = sapply(X = Annotation$kegg,FUN = function(X) if (!is.na(X)) if (X!='')  paste('path:map',X,collapse = "",sep='' ) else NA else NA  )
              Annotation$ontology = Annotation$namespace_1003
              Annotation$namespace_1003 = NULL
              Kegg_Annotation = getBM(attributes=c(opt$GENE_ID_TYPE,
                                                   'uniprotsptrembl'),
                                      mart = ensembl)
              
              colnames(Kegg_Annotation) = c(opt$GENE_ID_TYPE,keggConv_id_type)
              Annotation_flag = 'ensembl'
            }else{
              
              cat("Your GENE ID TYPE is not recognized ")
            }
            
            
          }else{
            cat("Unable to find the Species Annotation in Ensembl, choose from:")
            print(ensembl_dataset$description)
            print(plant$description)
          }
          
        }
      }
      
    }

    # Get KEGG information:
    KEGG_flag          = FALSE
    ORGANISM_KEGG_flag = FALSE
    KEGG_KAAS_flag     = FALSE
    GO_flag            = FALSE
    ORGANISM           = ''
    if(!(all(c('clusterProfiler') %in% installed.packages()))) {
      if (Sys.getenv("CONDA_PREFIX")!=""){
        source("https://bioconductor.org/biocLite.R")
        biocLite('clusterProfiler')
      }else{
        cat("The Bioconductor clusterProfiler package is not installed. You must install it for this script to work!")
      }
    } 
    library("clusterProfiler")

    if ("package:clusterProfiler" %in% search()){
      
      if(!(all(c('KEGGREST') %in% installed.packages()))) {
        if (Sys.getenv("CONDA_PREFIX")!=""){
          # if(!(all(c('devtools') %in% installed.packages()))) {
               # install.packages('devtools')
          # }
          # devtools::install_github('Bioconductor/KEGGREST',upgrade = 'never' )
          source("https://bioconductor.org/biocLite.R")
          biocLite('KEGGREST')
        }else{
          cat("The Bioconductor KEGGREST package is not installed. You must install it for this script to work!")
        }
      } 
      library("KEGGREST") 
      if ("package:KEGGREST" %in% search()){
        if (!is.na(Annotation)) {      
          if (Annotation_flag == 'OrgDb'){
            x=as.data.frame(eval(parse(text=sub(".db$", "_dbInfo()", opt$Annotation_db))))
            ORGANISM=x[x["name"]=="ORGANISM","value"]
            ORGANISM=clusterProfiler::search_kegg_organism(ORGANISM)$kegg_code
            if (length(ORGANISM)>0){
              Kegg_Annotation=bitr(rownames(countData), fromType=opt$GENE_ID_TYPE, toType=c('UNIPROT'), OrgDb=opt$Annotation_db)
            }
            
          }else{
            ORGANISMs = clusterProfiler::search_kegg_organism('')
            if (!is.na(opt$KEGG_Species)){
              opt$Species = opt$KEGG_Species
            }
            ORGANISM  = ORGANISMs$kegg_code[(sapply(X = ORGANISMs$scientific_name,FUN = function(X) stringi::stri_startswith(fixed =  stringi::stri_replace_last(str = stringi::stri_trans_tolower(opt$Species), fixed = ' genes',replacement = ''),str =  stringi::stri_trans_tolower(X)    )))]
            if (length(ORGANISM)==0){
              ORGANISMs = na.omit(ORGANISMs)
              ORGANISM  = ORGANISMs$kegg_code[(sapply(X = ORGANISMs$common_name,FUN = function(X) stringi::stri_cmp_eq( stringi::stri_replace_last(str = stringi::stri_trans_tolower(opt$Species), fixed = ' genes',replacement = '') , stringi::stri_trans_tolower(X)    )))]
              if (length(ORGANISM)==0){
                ORGANISM  = ORGANISMs$kegg_code[(sapply(X = ORGANISMs$common_name,FUN = function(X) stringi::stri_startswith(fixed = stringi::stri_replace_last(str = stringi::stri_trans_tolower(opt$Species), fixed = ' genes',replacement = '') , str = stringi::stri_trans_tolower(X)    )))]
              }
            }
          }
          
          
          
          if (length(ORGANISM)==1){       
            print(ORGANISM)
            kegg=keggConv(ORGANISM,keggConv_id_type) 
            uniprot =  unlist(lapply(X =names(kegg) ,FUN = function(x) rev(unlist(stringi::stri_split(str = x,regex = ":")))[1]))
            kegg=as.data.frame(kegg)
            kegg[keggConv_id_type]=uniprot
            
            KO=keggLink(ORGANISM,"ko")
            ko=names(KO)
            KO=as.data.frame(KO )
            colnames(KO)="kegg"
            KO["ko"]=ko
            
            temp=merge.data.frame(kegg,KO,by = "kegg",all = T)
            
            Pathway=keggLink(ORGANISM,"pathway")
            pathway=names(Pathway)
            Pathway=as.data.frame(Pathway)
            colnames(Pathway)="kegg"
            Pathway["pathway"]=pathway
            
            temp=merge.data.frame(temp,Pathway,by = "kegg",all = T)
            
            run=TRUE
            while (run){
              Pathway_info <- try(keggList("pathway",organism =ORGANISM),silent = T)
              if (!inherits(Pathway_info,"try-error")){
                run=FALSE
              }else{
                run=TRUE
              }
            }
            info=names(Pathway_info)
            Pathway_info=as.data.frame(Pathway_info)
            colnames(Pathway_info)="info"
            Pathway_info["pathway"]=info
            temp=merge.data.frame(temp,Pathway_info,by = "pathway",all.x = T)
            Kegg_Annotation = Kegg_Annotation[!is.na(Kegg_Annotation[,keggConv_id_type]),]
            Kegg_Annotation = merge.data.frame(Kegg_Annotation,temp,by =keggConv_id_type ,by.y = keggConv_id_type,all.x = T)
            # Kegg_Annotation=merge.data.frame(Kegg_Annotation,temp,by.x ="UNIPROT" ,by.y = "uniprot",all.x = T)
            Annotation$kegg = NULL 
            Annotation = merge.data.frame(Annotation,Kegg_Annotation,by.x =opt$GENE_ID_TYPE ,by.y = opt$GENE_ID_TYPE,all.x = T)
            Annotation$pathway_info = Annotation$info
            Annotation$info = NULL
            
            
            
            aggregate_by=Kegg_Annotation[opt$GENE_ID_TYPE]
            Kegg_Annotation[opt$GENE_ID_TYPE]=NULL
            Kegg_Annotation=aggregate.data.frame(x =Kegg_Annotation ,by = aggregate_by,FUN =function(x) paste(unique(na.omit(x)),sep = "|",collapse = "|"))
            
            ORGANISM_Pathway2gene=convert_agregate(Kegg_Annotation,opt$GENE_ID_TYPE,"pathway","[\\|]")
            ORGANISM_Pathway2gene=ORGANISM_Pathway2gene[ORGANISM_Pathway2gene$v1!='',]
            ORGANISM_Pathway2gene=ORGANISM_Pathway2gene[rev(colnames(ORGANISM_Pathway2gene))]
            ORGANISM_Pathway2name=Pathway_info[rev(colnames(Pathway_info))]
            ORGANISM_KEGG_flag  = TRUE
            
            write.table(ORGANISM_Pathway2name,
                        file = file.path(opt$outDir,paste('ORGANISM_Pathway2name','tab', sep = '.')) ,
                        quote = F,
                        row.names = F,
                        sep = "\t")
            
            write.table(ORGANISM_Pathway2gene,
                        file = file.path(opt$outDir,paste('ORGANISM_Pathway2gene','tab', sep = '.')) ,
                        quote = F,
                        row.names = F,
                        sep = "\t")
            
          }else{
            if ("kegg" %in% colnames(Annotation)){
              
              run=TRUE
              while (run){
                  Pathway_info <- try(keggList("pathway"),silent = T)
                  if (!inherits(Pathway_info,"try-error")){
                    run=FALSE
                  }else{
                    run=TRUE
                  }
              }
              
              
              info=names(Pathway_info)
              Pathway_info=as.data.frame(Pathway_info)
              colnames(Pathway_info)="info"
              Pathway_info["pathway"]=info
              
              
              Annotation = merge.data.frame(Annotation,Pathway_info,by.x ="kegg" ,by.y = "pathway",all.x = T)
              Annotation$pathway = Annotation$kegg
              Annotation$kegg = NULL
              Annotation$pathway_info = Annotation$info
              Annotation$info = NULL
              General_Kegg_Annotation = Annotation[c(opt$GENE_ID_TYPE,'pathway')]
              
              
              
              aggregate_by=General_Kegg_Annotation[opt$GENE_ID_TYPE]
              General_Kegg_Annotation[opt$GENE_ID_TYPE]=NULL
              General_Kegg_Annotation=aggregate.data.frame(x =General_Kegg_Annotation ,by = aggregate_by,FUN =function(x) paste(unique(na.omit(x)),sep = "|",collapse = "|"))
              
              Pathway2gene=convert_agregate(General_Kegg_Annotation,opt$GENE_ID_TYPE,"pathway","[\\|]")
              Pathway2gene=Pathway2gene[Pathway2gene$v1!='',]
              Pathway2gene=Pathway2gene[rev(colnames(Pathway2gene))]
              Pathway2name=Pathway_info[rev(colnames(Pathway_info))]
              KEGG_flag = TRUE
              
              write.table(Pathway2name,
                          file = file.path(opt$outDir,paste('Pathway2name','tab', sep = '.')) ,
                          quote = F,
                          row.names = F,
                          sep = "\t")
              
              write.table(Pathway2gene,
                          file = file.path(opt$outDir,paste('Pathway2gene','tab', sep = '.')) ,
                          quote = F,
                          row.names = F,
                          sep = "\t")
            }      
          }
        } else if (!is.na(opt$Trinotate)) {
          Annotation = read.csv(file = opt$Trinotate,sep = '\t')
          opt$GENE_ID_TYPE = colnames(Annotation)[1]
          Annotation[Annotation=='.']=NA
          
          blast_ontology = NA
          pos = stringr::str_detect(string = stringi::stri_trans_tolower(colnames(Annotation)),
                    pattern = 'gene_ontology')
          if (sum(pos)>0){
                blast_ontology = colnames(Annotation)[pos]
          }
          print(blast_ontology)
          if (!is.na(blast_ontology)){
            
              
              Annotation$GO = apply(X = Annotation[,blast_ontology],
                                    FUN = function(x) unlist(paste(unique(x),collapse = ' ')),
                                    MARGIN = 1)
              
              
              Annotation$GO_CC = sapply(X = Annotation$GO,
                                        FUN = function(X) stringi::stri_replace_all(str =  paste(unlist(unique(unlist(stringi::stri_extract(regex = 'GO:[0-9]+\\^cellular_component' ,
                                                                                                                                            str   = X ,
                                                                                                                                            mode = 'all')))),
                                                                                                 collapse = '/'),
                                                                                    fixed = '^cellular_component',
                                                                                    replacement = '') )
              
              Annotation$GO_BP = sapply(X = Annotation$GO,
                                        FUN = function(X) stringi::stri_replace_all(str =  paste(unlist(unique(unlist(stringi::stri_extract(regex = 'GO:[0-9]+\\^biological_process' ,
                                                                                                                                            str   = X ,
                                                                                                                                            mode = 'all')))),
                                                                                                 collapse = '/'),
                                                                                    fixed = '^biological_process',
                                                                                    replacement = '') )
              
              Annotation$GO_MF = sapply(X = Annotation$GO,
                                        FUN = function(X) stringi::stri_replace_all(str =  paste(unlist(unique(unlist(stringi::stri_extract(regex = 'GO:[0-9]+\\^molecular_function' ,
                                                                                                                                            str   = X ,
                                                                                                                                            mode = 'all')))),
                                                                                                 collapse = '/'),
                                                                                    fixed = '^molecular_function',
                                                                                    replacement = '') )
              
              
              
              Annotation$go_id = sapply(X = Annotation$GO,
                                        FUN = function(X) stringi::stri_replace_all(str =  paste(unlist(unique(unlist(stringi::stri_extract(regex = 'GO:[0-9]+' ,
                                                                                                                                            str   = X ,
                                                                                                                                            mode = 'all')))),
                                                                                                 collapse = '/'),
                                                                                    fixed = '^',
                                                                                    replacement = '') )
          }
          
          pos = stringr::str_detect(string = stringi::stri_trans_tolower(colnames(Annotation)),
                    pattern = 'kegg')
          
          if (sum(pos)>0){
                Kegg_string = colnames(Annotation)[pos][1]
                
                pos = stringr::str_detect(string = stringi::stri_trans_tolower(Annotation[,Kegg_string]),pattern = 'ko:k[0-9]+')
                pos[is.na(pos)]=F
                if (sum(pos)>0){
                    Annotation$KO = sapply(X = Annotation[,Kegg_string],
                                           FUN = function(X) stringi::stri_replace_all(str =  paste(unlist(stringi::stri_extract(regex = 'KO:K[0-9]+' ,
                                                                                                                                 str   = X ,
                                                                                                                                 mode = 'all')),
                                                                                                    collapse = '/'),
                                                                                       fixed = 'KO:',
                                                                                       replacement = 'ko:') )
                }else{
                    pos = stringr::str_detect(string = stringi::stri_trans_tolower(Annotation[,Kegg_string]),pattern = 'kegg:')
                    pos[is.na(pos)]=F
                    if (sum(pos)>0){
                        Annotation$KO = sapply(X   = Annotation[,Kegg_string],
                                               FUN = function(X) stringi::stri_replace_all(str = unlist(stringi::stri_extract(regex = 'KEGG:[A-z]+:[a-z A-Z _ 0-9]+' ,
                                                                                           str   = X ,
                                                                                           mode  = 'all')),
                                                       fixed = 'KEGG:',
                                                       replacement = ''))

                        Keggs = unique(as.vector(na.omit(unlist(Annotation$KO))))
                        subset_Keggs=split(Keggs, ceiling(seq_along(Keggs )/100))
                        result = c()
                        for (x in subset_Keggs){
                             REST=try(KEGGREST::keggLink('ko',x),silent = F)
                              
                              if (!inherits(REST,"try-error")){
                                result=c(result,REST)
                              }else{
                                print('KEGGREST Error')
                              }
                         }
                        
                        Annotation$KO = sapply(X   = Annotation$KO,
                                               FUN = function(X)  paste(as.vector(na.omit(unique(result[X]))),
                                                                                                     collapse = '/'))
                        Annotation[Annotation=='']=NA 
                    }
                }
          }
          Annotation[Annotation=='NA']=NA 
        }
        
        
        
        KEGG_KAAS_Data=NA
        if (!is.na(opt$KEGG_KAAS)) { 
          KEGG_KAAS_Data <- read.csv(opt$KEGG_KAAS,sep="\t",header = FALSE)
          colnames(KEGG_KAAS_Data) = c("Genes","KO")
          KEGG_KAAS_Data$KO = sapply(X =KEGG_KAAS_Data$KO, FUN = function(x) if (!is.na(x)) if (x!='')   paste( "ko:", x,collapse = "",sep = "") else NA else NA)
          if (!is.na(opt$GENE_ID_TYPE)) {
            KEGG_KAAS_Data$Genes = lapply(X =KEGG_KAAS_Data$Genes,FUN = function(x) unlist(stringi::stri_split(str = x,regex = "_"))[1] )
            KEGG_KAAS_Data$Genes = lapply(X =KEGG_KAAS_Data$Genes,FUN = function(x) rev(unlist(stringi::stri_split(str = x,regex = ":")))[1] )
          }
          
        }else if (!is.na(opt$Trinotate)) {
          if ("KO" %in% colnames(Annotation)){
              KEGG_KAAS_Data <- Annotation[,c(opt$GENE_ID_TYPE,"KO")] 
              KEGG_KAAS_Data = convert_agregate(Annotation, opt$GENE_ID_TYPE ,"KO","/")
              colnames(KEGG_KAAS_Data) = c("Genes","KO")
              KEGG_KAAS_Data = na.omit(KEGG_KAAS_Data)
              KEGG_KAAS_Data$KO = sapply(X =KEGG_KAAS_Data$KO, FUN = function(x) if (x=='')  NA else x)
          }
        }
        
        if (length(KEGG_KAAS_Data)==0) { 
           KEGG_KAAS_Data=NA
        }
        if (!is.na(KEGG_KAAS_Data)) { 
          
          
          temp=unique(as.vector(na.omit(KEGG_KAAS_Data$KO)))
          temp=split(temp, ceiling(seq_along(temp)/50))
          
          pathway=unlist(sapply(X =temp,FUN = function(x) keggLink_retry("pathway",x)))
          
          pathway= data.frame(KO = names(pathway) , pathway = pathway)
          pathway$KO = sapply(X =pathway$KO, FUN = function(x)  paste( "ko:",  rev(unlist(stringi::stri_split(str = x,regex = ":")))[1] ,collapse = "",sep = "") )
          pathway = pathway[!stringi::stri_startswith(str = pathway$pathway ,fixed = 'path:ko'),]
          
          KEGG_KAAS_Data = merge.data.frame(KEGG_KAAS_Data,pathway,by.x ="KO" ,by.y = "KO",all.x = T)
          
          run=TRUE
          while (run){
              Pathway_info <- try(keggList("pathway"),silent = T)
              if (!inherits(Pathway_info,"try-error")){
                run=FALSE
              }else{
                run=TRUE
              }
          }
          info=names(Pathway_info)
          Pathway_info=as.data.frame(Pathway_info)
          colnames(Pathway_info)="pathway_info"
          Pathway_info["pathway"]=info
          KEGG_KAAS_Data = merge.data.frame(KEGG_KAAS_Data,Pathway_info,by = "pathway",all.x = T)
          
          run=TRUE
          while (run){
              KO_info <- try(keggList("ko"),silent = T)
              if (!inherits(KO_info,"try-error")){
                run=FALSE
              }else{
                run=TRUE
              }
          }
          info=names(KO_info)
          KO_info=as.data.frame(KO_info)
          colnames(KO_info)="ko_info"
          KO_info["KO"]=info
          
          KEGG_KAAS_Data = merge.data.frame(KEGG_KAAS_Data,KO_info,by = "KO",all.x = T)
          colnames(KEGG_KAAS_Data) = sapply(X =colnames(KEGG_KAAS_Data), FUN = function(x) if (x!='Genes')  paste( "KASS_", x,collapse = "",sep = "") else x)
          if (!is.na(Annotation)) {  
            Annotation = merge.data.frame(Annotation,KEGG_KAAS_Data,by.x =opt$GENE_ID_TYPE ,by.y = "Genes",all.x = T)
          }else{
            Annotation = data.frame(Genes = rownames(countData))
            Annotation = merge.data.frame(Annotation,KEGG_KAAS_Data,by = "Genes",all.x = T)
            opt$GENE_ID_TYPE = 'Genes'
          }
          
          KASS_Pathway2gene = na.omit(Annotation[c('KASS_pathway',opt$GENE_ID_TYPE)])
          KASS_Pathway2gene = KASS_Pathway2gene[!duplicated.data.frame(KASS_Pathway2gene),]
          
          KASS_Pathway2name = na.omit(Annotation[c('KASS_pathway','KASS_pathway_info')])
          KASS_Pathway2name = KASS_Pathway2name[!duplicated.data.frame(KASS_Pathway2name),]
          
          KEGG_KAAS_flag = TRUE
          
          write.table(KASS_Pathway2name,
                      file = file.path(opt$outDir,paste('KASS_Pathway2name','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
          
          write.table(KASS_Pathway2gene,
                      file = file.path(opt$outDir,paste('KASS_Pathway2gene','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
        }
        
      }else{
        cat("The Bioconductor KEGGREST package is not installed. You must install it for this script to work!")
      }
    }

    if (!is.na(Annotation)) { 
      aggregate_by=Annotation[opt$GENE_ID_TYPE]
      Annotation[opt$GENE_ID_TYPE]=NULL
      Annotation=aggregate.data.frame(x =Annotation ,
                                      by = aggregate_by,
                                      FUN =function(x) paste(unique(na.omit(x)),sep = "/",collapse = "/"))
      rownames(Annotation)=unlist(Annotation[opt$GENE_ID_TYPE])
      Annotation<-apply(X =Annotation,
                        MARGIN = c(1,2),
                        FUN =function(x) stringi::stri_replace_all(str = x,replacement = " ",regex = ",") )
      Annotation=as.data.frame(Annotation)
      
      
      write.table(Annotation,
                  file = file.path(opt$outDir,paste('Annotation','tab', sep = '.')) ,
                  quote = F,
                  row.names = F,
                  sep = "\t")
      
      # Get GO information:
      if ("package:clusterProfiler" %in% search()){      
        if ((Annotation_flag != 'OrgDb') & ("go_id" %in% colnames(Annotation))) {
          
          GO2gene           = convert_agregate(Annotation,opt$GENE_ID_TYPE,"go_id","/")
          GO2gene           = GO2gene[GO2gene$v1!='',]
          GO2gene           = sapply(GO2gene,FUN = function(x) stringi::stri_replace_all(str = x,replacement = "",regex = " "))
          GO2gene           = GO2gene[,c("v1","index")]
          #convert GO indirect to direct GOs
          GO2gene           = clusterProfiler::buildGOmap(GO2gene)
          # annotate the GO to TERMs
          Goterm            = merge.data.frame(x= clusterProfiler::go2term(GO2gene$GO), y=clusterProfiler::go2ont(GO2gene$GO) ,by='go_id')
          Goterm            = Goterm[!duplicated.data.frame(Goterm),]
          GO2name           = merge.data.frame(x = GO2gene,y = Goterm,by.y = "go_id",by.x ="GO" ,sort = FALSE)
          
          GO2name_MF        = GO2name[GO2name$Ontology=="MF",c('GO','Term')]
          GO2name_BP        = GO2name[GO2name$Ontology=="BP",c('GO','Term')]
          GO2name_CC        = GO2name[GO2name$Ontology=="CC",c('GO','Term')]
          GO2name_MF        = GO2name_MF[!duplicated.data.frame(GO2name_MF),]
          GO2name_BP        = GO2name_BP[!duplicated.data.frame(GO2name_BP),]
          GO2name_CC        = GO2name_CC[!duplicated.data.frame(GO2name_CC),]
          
          GO2gene_MF        = GO2name[GO2name$Ontology=="MF",c('GO','Gene')]
          GO2gene_BP        = GO2name[GO2name$Ontology=="BP",c('GO','Gene')]
          GO2gene_CC        = GO2name[GO2name$Ontology=="CC",c('GO','Gene')]
          GO2gene_MF        = GO2gene_MF[!duplicated.data.frame(GO2gene_MF),]
          GO2gene_BP        = GO2gene_BP[!duplicated.data.frame(GO2gene_BP),]
          GO2gene_CC        = GO2gene_CC[!duplicated.data.frame(GO2gene_CC),]
          
          GO_flag           = TRUE
          write.table(GO2gene_MF,
                      file = file.path(opt$outDir,paste('GO2gene_MF','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
          
          write.table(GO2name_MF,
                      file = file.path(opt$outDir,paste('GO2name_MF','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
          
          
          write.table(GO2gene_BP,
                      file = file.path(opt$outDir,paste('GO2gene_BP','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
          
          write.table(GO2name_BP,
                      file = file.path(opt$outDir,paste('GO2name_BP','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
                      
          write.table(GO2gene_CC,
                      file = file.path(opt$outDir,paste('GO2gene_CC','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
          
          write.table(GO2name_CC,
                      file = file.path(opt$outDir,paste('GO2name_CC','tab', sep = '.')) ,
                      quote = F,
                      row.names = F,
                      sep = "\t")
        }
      }
      
    }

} else{
    
    
    if (!is.na(opt$Annotation_db) ){
      
          # Check if required packages are installed:
          if(!(all(c(opt$Annotation_db) %in% installed.packages()))) {
            if (Sys.getenv("CONDA_PREFIX")!=""){
              source("https://bioconductor.org/biocLite.R")
              biocLite(opt$Annotation_db)
              library(opt$Annotation_db,character.only =T)
            }else{
              cat("The Bioconductor Annotation Data Base package is not installed. You must install it for this script to work!")
            }
          }else{
            library(opt$Annotation_db,character.only =T)  
          } 
          
          if (paste("package:",opt$Annotation_db,sep='') %in% search()){
            Annotation_flag = 'OrgDb'
          }
    }

    Annotation <- read.delim(Annotation_file, sep="\t", row.names=1,quote = "")
    KEGG_flag          = FALSE
    ORGANISM_KEGG_flag = FALSE
    KEGG_KAAS_flag     = FALSE
    GO_flag            = FALSE
    ORGANISM           = ''
    Pathway2name_file = file.path(opt$outDir,paste('Pathway2name','tab', sep = '.'))
    Pathway2gene_file = file.path(opt$outDir,paste('Pathway2gene','tab', sep = '.'))
    if ((file.exists(Pathway2name_file)) & (file.exists(Pathway2gene_file))){
        Pathway2name = read.delim(Pathway2name_file, sep="\t", row.names=NULL)
        Pathway2gene = read.delim(Pathway2gene_file, sep="\t", row.names=NULL)
        KEGG_flag = TRUE
    }
    
    KASS_Pathway2name_file = file.path(opt$outDir,paste('KASS_Pathway2name','tab', sep = '.'))
    KASS_Pathway2gene_file = file.path(opt$outDir,paste('KASS_Pathway2gene','tab', sep = '.'))
    if ((file.exists(KASS_Pathway2name_file)) & (file.exists(KASS_Pathway2gene_file))){
        KASS_Pathway2name = read.delim(KASS_Pathway2name_file, sep="\t", row.names=NULL)
        KASS_Pathway2gene = read.delim(KASS_Pathway2gene_file, sep="\t", row.names=NULL)
        KEGG_KAAS_flag = TRUE
    }
     
    ORGANISM_Pathway2name_file = file.path(opt$outDir,paste('ORGANISM_Pathway2name','tab', sep = '.'))
    ORGANISM_Pathway2gene_file = file.path(opt$outDir,paste('ORGANISM_Pathway2gene','tab', sep = '.'))
    if ((file.exists(ORGANISM_Pathway2name_file)) & (file.exists(ORGANISM_Pathway2gene_file))){
        ORGANISM_Pathway2name = read.delim(ORGANISM_Pathway2name_file, sep="\t", row.names=NULL)
        ORGANISM_Pathway2gene = read.delim(ORGANISM_Pathway2gene_file, sep="\t", row.names=NULL)
        ORGANISM_KEGG_flag  = TRUE
    }
    
    GO_flag = FALSE
    GO2gene_MF_file = file.path(opt$outDir,paste('GO2gene_MF','tab', sep = '.'))
    GO2name_MF_file = file.path(opt$outDir,paste('GO2name_MF','tab', sep = '.'))
    GO2gene_BP_file = file.path(opt$outDir,paste('GO2gene_BP','tab', sep = '.'))
    GO2name_BP_file = file.path(opt$outDir,paste('GO2name_BP','tab', sep = '.'))
    GO2gene_CC_file = file.path(opt$outDir,paste('GO2gene_CC','tab', sep = '.'))
    GO2name_CC_file = file.path(opt$outDir,paste('GO2name_CC','tab', sep = '.'))
    
    GO2gene_MF = NA
    GO2name_MF = NA
    
    GO2gene_BP = NA
    GO2name_BP = NA
    
    GO2gene_CC = NA
    GO2name_CC = NA
    
    if ((file.exists(GO2gene_BP_file)) & (file.exists(GO2name_BP_file))){
        GO2gene_BP = read.delim(GO2gene_BP_file, sep="\t", row.names=NULL)
        GO2name_BP = read.delim(GO2name_BP_file, sep="\t", row.names=NULL)
        GO_flag  = TRUE
    }
    
    if ((file.exists(GO2gene_MF_file)) & (file.exists(GO2name_MF_file))){
        GO2gene_MF = read.delim(GO2gene_MF_file, sep="\t", row.names=NULL)
        GO2name_MF = read.delim(GO2name_MF_file, sep="\t", row.names=NULL)
        GO_flag  = TRUE
    }
    
    if ((file.exists(GO2gene_CC_file)) & (file.exists(GO2name_CC_file))){
        GO2gene_CC = read.delim(GO2gene_CC_file, sep="\t", row.names=NULL)
        GO2name_CC = read.delim(GO2name_CC_file, sep="\t", row.names=NULL)
        GO_flag  = TRUE
    }
    
    if  (any(c(GO_flag,ORGANISM_KEGG_flag,KEGG_KAAS_flag,KEGG_flag))){
        if(!(all(c('clusterProfiler') %in% installed.packages()))) {
          if (Sys.getenv("CONDA_PREFIX")!=""){
            source("https://bioconductor.org/biocLite.R")
            biocLite('clusterProfiler')
          }else{
            cat("The Bioconductor clusterProfiler package is not installed. You must install it for this script to work!")
          }
        } 
        library("clusterProfiler") 
    }
}

if (!is.na(opt$Filter_KEGG_pathways_by_taxon)){
    if (KEGG_KAAS_flag){
        Pathways2Filter = Filter_Pathways_By_Taxa(opt$Filter_KEGG_pathways_by_taxon)
        KASS_Pathway2name = KASS_Pathway2name[KASS_Pathway2name[1] %in% Pathways2Filter,]
        KASS_Pathway2gene = KASS_Pathway2gene[KASS_Pathway2gene[1] %in% Pathways2Filter,]
        
    } else if (KEGG_flag ) {
        Pathways2Filter = Filter_Pathways_By_Taxa(opt$Filter_KEGG_pathways_by_taxon)
        Pathway2name = Pathway2name[Pathway2name[1] %in% Pathways2Filter,]
        Pathway2gene = Pathway2gene[Pathway2gene[1] %in% Pathways2Filter,]
    }
}


if (!is.na(opt$Genes_file)) {
    genes = read.delim(opt$Genes_file,header = F)
    genes = genes$V1
    genes2use = intersect(unique(genes),rownames(countData))
    print('Before Gene Filtering by a user List:')
    print(dim(countData))
    countData <- countData[genes2use, ]
    print('After Gene Filtering by a user List:')
    print(dim(countData))
    
    SummarizedExperiment::assay(ProteinGroupsData_SE) <- countData
}


if (opt$USE_INPUT_GENES_AS_BACKGROUND){
    if (KEGG_flag == TRUE){
        print('Before INPUT GENES AS BACKGROUND Filtering:')
        print(dim(Pathway2gene))
        genes2use = intersect(unique(Pathway2gene[,2]),rownames(countData))
        Pathway2gene = Pathway2gene[Pathway2gene[,2] %in% genes2use,]
        print('After INPUT GENES AS BACKGROUND Filtering:')
        print(dim(Pathway2gene))
    }
    if (KEGG_KAAS_flag == TRUE){
        print('Before INPUT GENES AS BACKGROUND Filtering:')
        print(dim(KASS_Pathway2gene))
        genes2use = intersect(unique(KASS_Pathway2gene[,2]),rownames(countData))
        KASS_Pathway2gene = KASS_Pathway2gene[KASS_Pathway2gene[,2] %in% genes2use,]
        print('After INPUT GENES AS BACKGROUND Filtering:')
        print(dim(KASS_Pathway2gene))
    }
    
    if (ORGANISM_KEGG_flag == TRUE){
        print('Before INPUT GENES AS BACKGROUND Filtering:')
        print(dim(ORGANISM_Pathway2gene))
        genes2use = intersect(unique(ORGANISM_Pathway2gene[,2]),rownames(countData))
        ORGANISM_Pathway2gene = ORGANISM_Pathway2gene[ORGANISM_Pathway2gene[,2] %in% genes2use,]
        print('After INPUT GENES AS BACKGROUND Filtering:')
        print(dim(ORGANISM_Pathway2gene))
    }
    
    if (GO_flag == TRUE){
        if (!is.na(GO2gene_BP)){
            print('GO BP : Before INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_BP))
            genes2use = intersect(unique(GO2gene_BP[,2]),rownames(countData))
            GO2gene_BP = GO2gene_BP[GO2gene_BP[,2] %in% genes2use,]
            print('GO BP : After INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_BP))
        }
        if (!is.na(GO2gene_MF)){
            print('GO MF : Before INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_MF))
            genes2use = intersect(unique(GO2gene_MF[,2]),rownames(countData))
            GO2gene_MF = GO2gene_MF[GO2gene_MF[,2] %in% genes2use,]
            print('GO BP : After INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_MF))
        }
        if (!is.na(GO2gene_CC)){
            print('GO CC : Before INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_CC))
            genes2use = intersect(unique(GO2gene_CC[,2]),rownames(countData))
            GO2gene_CC = GO2gene_CC[GO2gene_CC[,2] %in% genes2use,]
            print('GO BP : After INPUT GENES AS BACKGROUND Filtering:')
            print(dim(GO2gene_CC))
        }
    }

}


##############Filttering the data##############################

if ((opt$FILTER_SAMPLES) | (opt$FILTER_PROTEIN)){
  
    if (opt$FILTER_SAMPLES){
        countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
        
        P = plot_numbers(ProteinGroupsData_SE)

        pdf(file = file.path(opt$outDir,"Pre_Samples_Filtering_PerSample_Protein.pdf"))
        print(P)
        dev.off() 
        
        Missing_values = apply(X = countData,MARGIN = 2,FUN = function(x) sum(is.na(x)) )/dim(countData)[1]
        print('Will Remove these Samples From the Analysis:')
        print(names(Missing_values[Missing_values>opt$FILTER_SAMPLES_CUTOFF]))
        ProteinGroupsData_SE = ProteinGroupsData_SE[,names(Missing_values[Missing_values<opt$FILTER_SAMPLES_CUTOFF])]
        
        P = plot_numbers(ProteinGroupsData_SE)
        pdf(file = file.path(opt$outDir,"After_Samples_Filtering_PerSample_Protein.pdf"))
        print(P)
        dev.off() 
    }
    
    if (opt$FILTER_PROTEIN){
        print('Filtering Proteins')
        print('Before Filtering:')
        print(dim(ProteinGroupsData_SE))
        
        P = plot_frequency(ProteinGroupsData_SE)
        pdf(file = file.path(opt$outDir,"Pre_Proteins_Filtering.pdf"))
        print(P)
        dev.off() 
        
        ProteinGroupsData_SE <- filter_missval(ProteinGroupsData_SE, thr = opt$FILTER_PROTEIN_CUTOFF)
        
        P = plot_frequency(ProteinGroupsData_SE)
        pdf(file = file.path(opt$outDir,"After_Proteins_Filtering.pdf"))
        print(P)
        dev.off() 
        
        P = plot_numbers(ProteinGroupsData_SE)
        pdf(file = file.path(opt$outDir,"After_Proteins_Filtering_PerSample_Protein.pdf"))
        print(P)
        dev.off() 
        print('After Filtering:')
        print(dim(ProteinGroupsData_SE))
        countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
        
    }
}        
##################Filttering the data END######################

#################Add Number to Count Data######################
countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
countData = countData + opt$Add2Count
SummarizedExperiment::assay(ProteinGroupsData_SE) = countData
write.csv(x =countData ,file = file.path(opt$outDir,"CountData.tab"))

################## Normalizing the data    ######################
if (opt$NORMALIZATION_TYPE == 'VSD'){
    Raw_ProteinGroupsData_SE = ProteinGroupsData_SE
    ProteinGroupsData_SE = normalize_vsn(ProteinGroupsData_SE)
    P = plot_normalization(Raw_ProteinGroupsData_SE, ProteinGroupsData_SE)
    pdf(file = file.path(opt$outDir,"Normalization.pdf"))
    print(P)
    dev.off() 
}else{
    countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
    countData = log2(countData)
    if (opt$MEDIAN_NORMALIZATION){
        countData = equalMedianNormalization(countData)
    }
    Raw_ProteinGroupsData_SE = ProteinGroupsData_SE
    SummarizedExperiment::assay(ProteinGroupsData_SE) = countData
    P = plot_normalization(Raw_ProteinGroupsData_SE, ProteinGroupsData_SE)
    pdf(file = file.path(opt$outDir,"Normalization.pdf"))
    print(P)
    dev.off() 
}

################## Normalizing the data END######################

################## Impute the data    ######################
P = plot_missval(ProteinGroupsData_SE)
pdf(file = file.path(opt$outDir,"MissingData.pdf"))
print(P)
dev.off() 

P = plot_detect(ProteinGroupsData_SE)
pdf(file = file.path(opt$outDir,"MissingData_Distributions.pdf"))
print(P)
dev.off() 

Raw_ProteinGroupsData_SE = ProteinGroupsData_SE
raw_Data = SummarizedExperiment::assay(Raw_ProteinGroupsData_SE)

Imputed = FALSE
# MNAR
if (opt$IMPUTATION_METHOD == 'MLE'){
    ProteinGroupsData_SE <- impute(ProteinGroupsData_SE, fun = "MLE")
    Imputed = TRUE
}
if (opt$IMPUTATION_METHOD == 'MinProb'){
    ProteinGroupsData_SE <- impute(ProteinGroupsData_SE, fun = "MinProb")
    Imputed = TRUE
}
if (opt$IMPUTATION_METHOD == 'QRILC'){
    ProteinGroupsData_SE <- impute(ProteinGroupsData_SE, fun = "QRILC")
    Imputed = TRUE
}

if (opt$IMPUTATION_METHOD == 'man'){
    ProteinGroupsData_SE <- impute(ProteinGroupsData_SE, fun = "man", shift = opt$IMPUTATION_SHIFT, scale = opt$IMPUTATION_SCALE)
    Imputed = TRUE
}
# MAR 
if (opt$IMPUTATION_METHOD == 'knn'){
    ProteinGroupsData_SE <- impute(ProteinGroupsData_SE, fun = "knn")
    Imputed = TRUE
}


if (Imputed){
    imputed  = SummarizedExperiment::assay(ProteinGroupsData_SE)
    Only_imputed_ProteinGroupsData_SE = ProteinGroupsData_SE
    imputed[!is.na(raw_Data)] = NA
    SummarizedExperiment::assay(Only_imputed_ProteinGroupsData_SE) = imputed
    
    
    P = plot_imputation(Raw_ProteinGroupsData_SE, ProteinGroupsData_SE,Only_imputed_ProteinGroupsData_SE)
    pdf(file = file.path(opt$outDir,"Imputation_Distributions.pdf"))
    print(P)
    dev.off() 
}else{
    P = plot_imputation(ProteinGroupsData_SE)
    pdf(file = file.path(opt$outDir,"Imputation_Distributions.pdf"))
    print(P)
    dev.off() 
}

################## Impute the data END######################

################## Remove Batch Effect ######################
  
  ProteinGroupsData_SE_BatchRemoved =NULL
  if (!is.na(opt$removeBatchEffect)){
    ProteinGroupsData_SE_BatchRemoved = ProteinGroupsData_SE
    Original_colData   = SummarizedExperiment::colData(ProteinGroupsData_SE)
    Original_countData = SummarizedExperiment::assay(ProteinGroupsData_SE) 
    if (opt$removeBatchEffect_method=="sva"){
      if(!(all(c('sva') %in% installed.packages()))) {
        if (Sys.getenv("CONDA_PREFIX")!=""){
          source("http://bioconductor.org/biocLite.R")
          try(biocLite("sva", version = "3.8"),silent = F)
        }else{
          cat("The Bioconductor sva package is not installed. You must install it for this script to work!")
        }
      } 
      try(library("sva"),silent = F)
      if ("package:sva" %in% search()==FALSE){
        cat(sprintf("%s","The Bioconductor sva package is not installed!! will use limma instead"))
        opt$removeBatchEffect_method="limma"
      }
    }
    BatchEffects = unlist(stringi::stri_split(str = opt$removeBatchEffect ,regex = ','))
    if (opt$removeBatchEffect_method=="sva"){
      if (length(BatchEffects)>1){
        cat(sprintf("%s","It is Not possible to use more then one batch effect using the sva package, will use only the first one!!"))
      }
      DESIGN_list = unlist(stringi::stri_split( stringi::stri_replace(str = opt$DESIGN,
                                                                      regex =' |~',
                                                                      mode = 'all',
                                                                      replacement = ''),
                                                fixed = '+'))
      New_DESIGN =paste0('~',paste(DESIGN_list[DESIGN_list!=BatchEffects[1]],collapse ='+'))
      
      modcombat = model.matrix( as.formula(New_DESIGN) , data=Original_colData)
      
      combat_edata<-try(ComBat(dat = Original_countData,
                               batch = Original_colData[,BatchEffects[1]],
                               mod = modcombat,
                               par.prior = T,
                               mean.only=F),
                        silent = T)
      if (inherits(combat_edata,"try-error")){
        cat(sprintf("%s","Failed to correct batch effect using parametric adjustment will try using limma instead!!\n"))
        
        SummarizedExperiment::assay(ProteinGroupsData_SE_BatchRemoved) = limma::removeBatchEffect(Original_countData,
                                                            batch = Original_colData[,BatchEffects[1]])
        
      }else{
        SummarizedExperiment::assay(ProteinGroupsData_SE_BatchRemoved) = combat_edata
      }   
      
    }else{
      
      if (length(BatchEffects)>1){
        SummarizedExperiment::assay(ProteinGroupsData_SE_BatchRemoved) = limma::removeBatchEffect(Original_countData,
                                                                   batch = Original_colData[,BatchEffects[1]],
                                                                   batch2= Original_colData[,BatchEffects[2]])
      }else{
        SummarizedExperiment::assay(ProteinGroupsData_SE_BatchRemoved) =  limma::removeBatchEffect(Original_countData,
                                                                    batch = Original_colData[,BatchEffects[1]])
      }
    }
  }
  
################## Remove Batch Effect END######################

################## Design ########################################

if (opt$only_clustering==FALSE){
  if (is.na(opt$DESIGN)){
    opt$CONTRAST = 'No_DESIGN'
    print('No DESIGN found, will only normalize and cluster all Proteins')
  }
  
  if (!is.na(opt$collapseReplicates)){
    if (opt$collapseReplicates %in% colnames(ProteinGroupsData_SE)){
      collapsed_DataSet <- try( collapseReplicates(ProteinGroupsData_SE,ProteinGroupsData_SE[[opt$collapseReplicates]] ) ,silent = T)
      if (inherits(collapsed_DataSet,"try-error")){
        print('Failed to collapse Replicates !!!')
      }else{
        collapsed_DESeqDataSet$Library_sizes=apply(X = as.data.frame(counts(collapsed_DESeqDataSet)),MARGIN = 2,FUN = sum)
        ProteinGroupsData_SE = collapsed_DataSet
        countData = SummarizedExperiment::assay(ProteinGroupsData_SE)
      }
    }else{
      print('The field to be used for Replicates collapse is not found in the Sample Data !!!')
    }
  }

  test_count=list()
  
  if ((!is.na(opt$CONTRAST)) & (opt$CONTRAST != "") & (opt$CONTRAST != "No_DESIGN")){
    test_count = unlist(stringi::stri_split(str = opt$CONTRAST ,fixed = "|"))
    
  }
  
  if (!is.na(opt$significant_genes)){ 
        sig.genes = unlist(stringi::stri_split(str = opt$significant_genes,regex = ','))
  }else if (!is.na(opt$significant_genes_file)) {
        sig.genes = read.delim(opt$significant_genes_file,header = F)
        sig.genes = sig.genes$V1
  }else{
        sig.genes = c()
  }
  
  
  
  
  
  
    if (length(test_count)>0){
        
        contrasts = c()
        for (contrast in test_count) {
            contrasts = c(contrasts,paste0(unlist(stringi::stri_split(str = contrast ,fixed = ",")),collapse = '_vs_'))
        }
        print(contrasts)
        results <- test_diff(ProteinGroupsData_SE, type = "manual", 
                                 test = contrasts,design_formula = as.formula(opt$DESIGN),pep_count = pep.count.table)
        names(results) = contrasts
          
        colnames(ProteinGroupsData_SE) = ProteinGroupsData_SE$label
        Sig_Gene = create_excel_output(se                    = ProteinGroupsData_SE,
                            results               = results,
                            opt                   = opt,
                            contrusts             = test_count,
                            output_path           = paste0(opt$outDir,"summary_table"),
                            linear_fc_cutoff      = opt$FoldChange,
                            post_linear_fc_cutoff = opt$Post_statistical_FoldChange,
                            alpha_cutoff          = opt$ALPHA,
                            post_alpha            = opt$Post_statistical_ALPHA,
                            Annotation            = Annotation)
        
        create_excel_output(se                    = ProteinGroupsData_SE,
                            results               = results,
                            opt                   = opt,
                            contrusts             = test_count,
                            output_path           = paste0(opt$outDir,"Only_Significant_Genes_summary_table"),
                            linear_fc_cutoff      = opt$FoldChange,
                            post_linear_fc_cutoff = opt$Post_statistical_FoldChange,
                            alpha_cutoff          = opt$ALPHA,
                            post_alpha            = opt$Post_statistical_ALPHA,
                            use_only_sig_gene     = T,
                            Annotation            = Annotation)

        if (!is.null(ProteinGroupsData_SE_BatchRemoved)){
            colnames(ProteinGroupsData_SE_BatchRemoved) = ProteinGroupsData_SE_BatchRemoved$label
            Sig_Gene = create_excel_output(se                    = ProteinGroupsData_SE_BatchRemoved,
                                results               = results,
                                opt                   = opt,
                                contrusts             = test_count,
                                output_path           = paste0(opt$outDir,"summary_table_batch_effect"),
                                linear_fc_cutoff      = opt$FoldChange,
                                post_linear_fc_cutoff = opt$Post_statistical_FoldChange,
                                alpha_cutoff          = opt$ALPHA,
                                post_alpha            = opt$Post_statistical_ALPHA,
                                Annotation            = Annotation)
            
            create_excel_output(se                    = ProteinGroupsData_SE_BatchRemoved,
                                results               = results,
                                opt                   = opt,
                                contrusts             = test_count,
                                output_path           = paste0(opt$outDir,"Only_Significant_Genes_summary_table_batch_effect"),
                                linear_fc_cutoff      = opt$FoldChange,
                                post_linear_fc_cutoff = opt$Post_statistical_FoldChange,
                                alpha_cutoff          = opt$ALPHA,
                                post_alpha            = opt$Post_statistical_ALPHA,
                                use_only_sig_gene     = T,
                                Annotation            = Annotation)
 
        }
    }
    genral_test_name <- "GENERAL"
  
}else{
  DESeqDataSet_base=NA
  test_count=c('only_clustering')
  if (!is.na(opt$significant_genes)){ 
        sig.genes = unlist(stringi::stri_split(str = opt$significant_genes,regex = ','))
  }else if (!is.na(opt$significant_genes_file)) {
        sig.genes = read.delim(opt$significant_genes_file,header = F)
        sig.genes = sig.genes$V1
  }else{
        sig.genes = c()
  }
  # opt$sig.genes = sig.genes
}



base_out_dir=opt$outDir

Rmarkdown_flag=FALSE
if (!is.na(opt$Rmarkdown)){
  if((all(c('plotly','DT','clusterProfiler','rmarkdown') %in% installed.packages()))) {
    Rmarkdown_flag=TRUE
  } else {
    cat("In order to use the Rmarkdown option all of the following R packages need to be installed: 'plotly','DT','clusterProfiler','rmarkdown'")  
  }
}

save.image(file.path(base_out_dir,'Session.RSession'))



  if (length(test_count)==0){
    test_count = c('No_Statistics')
  }
  
  if ((!is.na(opt$CONTRAST)) & (opt$CONTRAST == "No_DESIGN")){
    test_count = c('No_DESIGN')
  }
  
   if ((!is.na(opt$RandomForest))){
    test_count = c(test_count,'Random_Forest')
  }
  
   if ((length(Sig_Gene)>0)){
    test_count = c(test_count,'only_clustering')
    opt$significant_genes = paste(Sig_Gene,collapse = ',')
  }


Original_colData   = colData
Original_countData = countData

DESeqDataSet_Results = NA
Normalized_counts = NA
Normalized_counts_list=c()




for (test2do in test_count){
  print(test2do)
  if (Rmarkdown_flag){
    if ((test2do=='No_DESIGN')||(test2do=='only_clustering') ||(test2do=='No_Statistics') ||(test2do=='Random_Forest') ){
      test_name=test2do
    }else{
      contrast_list = unlist(stringi::stri_split(str = test2do,regex = ','))
      if (length(contrast_list)==2){
          test_name = paste(contrast_list[1],contrast_list[2],sep = '_vs_')
      }else{
          test_name = paste(contrast_list[2],contrast_list[3],sep = '_vs_')
      }
    }
    gc()
    rmarkdown::render(input             = opt$Rmarkdown,
                      output_file       = file.path(base_out_dir,paste('Final_Report',test_name,'html', sep = '.')),
                      intermediates_dir = base_out_dir,
                      clean             = TRUE,
                      envir             =  new.env(),
                      params            = list(
                        opt                = opt,
                        test2do            = test2do,
                        results            = results[[test_name]],
                        general            = F,
                        SE                 = ProteinGroupsData_SE,
                        SE_BatchRemoved    = ProteinGroupsData_SE_BatchRemoved,
                        base_out_dir       = base_out_dir,
                        Annotation         = Annotation,
                        Annotation_flag    = Annotation_flag,
                        ORGANISM           = ORGANISM,
                        KEGG_flag          = KEGG_flag,
                        ORGANISM_KEGG_flag = ORGANISM_KEGG_flag,
                        KEGG_KAAS_flag     = KEGG_KAAS_flag,
                        GO_flag            = GO_flag,
                        GO2gene_MF         = GO2gene_MF,
                        GO2name_MF         = GO2name_MF,
                        GO2gene_BP         = GO2gene_BP,
                        GO2name_BP         = GO2name_BP,
                        GO2gene_CC         = GO2gene_CC,
                        GO2name_CC         = GO2name_CC
                      ))
    gc()
  } 
  
}

